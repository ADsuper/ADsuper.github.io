<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[RxJava 之变换（二）]]></title>
      <url>%2F2017%2F05%2F13%2FRxJava%E4%B9%8B%E5%8F%98%E6%8D%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
      <content type="text"><![CDATA[前言 本篇文章是根据 给 Android 开发者的 RxJava 详解 做的笔记 本篇文章主要介绍的是 RxJava 变换 map 和 flatMap 的使用，以及 throttleFirst 附上本人之前的一篇链接：RxJava 基础概念 正文一、变换RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。 1.1 先介绍下 FunX 系列的方法，因为要用到 它和 ActionX 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。 Fun1 接口如下 12345678/** * Represents a function with one argument. * @param &lt;T&gt; the first argument type * @param &lt;R&gt; the result type */public interface Func1&lt;T, R&gt; extends Function &#123; R call(T t);&#125; 1.2 变换之 map() ，看例子12345678910111213141516171819Student student1 = new Student(&quot;张三&quot;,20);Student student2 = new Student(&quot;李四&quot;,30);Student student3 = new Student(&quot;王五&quot;,40);//// 输入类型 StudentObservable.just(student1,student2,student3) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123;// 参数类型 Student String name = student.getName(); return name;//返回类型 String &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123;//参数类型 String @Override public void call(String s) &#123; Log.i(&quot;map&quot;,s); &#125; &#125;); student 类如下： 12345678910111213141516171819public class Student &#123; private String name; private int age; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; &#125; 可以看到 Observable 中原来的参数是 Student 对象，而最后我们需要的是String类型的 name，这里使用了 map 来实现这一转换的过程。 1.3 变换之 flatMap() 我把 Student 类加个属性—课程的集合 123456789public class Student &#123; private String name; private int age; //课程 private ArrayList&lt;Couser&gt; courseList; ...&#125; 课程类如下： 1234567public class Couser &#123; private String couserName; private int couserId; ...&#125; 需求：打印出每个学生所需要修的所有课程的名称跟上一个 map 的例子的区别在于— 每个学生只有一个名字，但却有多个课程。 当然也能使用 map 来实现 ，将课程集合看成一个类型就行了，就像学生名字的 String 类型一样，然后遍历打印课程名称，如下： 123456789101112131415161718192021222324252627 ArrayList&lt;Couser&gt; list = new ArrayList&lt;&gt;(); list.add(new Couser(&quot;语文&quot;,1)); list.add(new Couser(&quot;数学&quot;,2)); list.add(new Couser(&quot;英语&quot;,3)); Student student1 = new Student(&quot;张三&quot;,20,list);ArrayList&lt;Couser&gt; list1 = new ArrayList&lt;&gt;(); list1.add(new Couser(&quot;政治&quot;,4)); list1.add(new Couser(&quot;历史&quot;,5)); list1.add(new Couser(&quot;地理&quot;,6)); Student student2 = new Student(&quot;张三&quot;,20,list1); Observable.just(student1,student2) .map(new Func1&lt;Student, ArrayList&lt;Couser&gt;&gt;() &#123; @Override public ArrayList&lt;Couser&gt; call(Student student) &#123; return student.getCourseList(); &#125; &#125;) .subscribe(new Action1&lt;ArrayList&lt;Couser&gt;&gt;() &#123; @Override public void call(ArrayList&lt;Couser&gt; cousers) &#123; for (Couser couser : cousers) &#123; Log.i(&quot;map&quot;,couser.getCouserName()); &#125; &#125; &#125;); 注意此处观察者 Action1 的参数类型为 ArrayList cousers 。 使用 flatMap() 来实现如下： 1234567891011121314Observable.just(student1,student2) .flatMap(new Func1&lt;Student, Observable&lt;Couser&gt;&gt;() &#123; @Override public Observable&lt;Couser&gt; call(Student student) &#123; return Observable.from(student.getCourseList()); &#125; &#125;) .subscribe(new Action1&lt;Couser&gt;() &#123; @Override public void call(Couser couser) &#123; Log.i(&quot;map&quot;,couser.getCouserName()); &#125; &#125;); 从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象 flatMap() 的原理： 第一步，使用传入的事件对象创建一个 Observable 对象； 第二步， 并不发送这个 Observable, 而是将它激活，于是它开始发送事件； 第三步， 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。 这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。 flatMap() 的优点： 由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。这样可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。也就是说在 return Observable.from(student.getCourseList()); 中做进一步的网络请求封装。 1.4 变换还有其他的方式，比如 lift 和 compose ，自行研究。。。二、防抖动效果 throttleFirst() 作用：在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤 比如在 onNext() 方法中有打开一个新页面的逻辑，添加这个方法之后，就不用担心因为手抖打开两个重复的界面，或者重复的操作 12//设置防抖间隔为 500msthrottleFirst(500, TimeUnit.MILLISECONDS) 用法如下： 1234567891011121314151617Observable.just(student1,student2) .flatMap(new Func1&lt;Student, Observable&lt;Couser&gt;&gt;() &#123; @Override public Observable&lt;Couser&gt; call(Student student) &#123; return Observable.from(student.getCourseList()); &#125; &#125;) //防抖动 .throttleFirst(500, TimeUnit.MILLISECONDS) .subscribe(new Action1&lt;Couser&gt;() &#123; @Override public void call(Couser couser) &#123; Log.i(&quot;map&quot;,couser.getCouserName()); &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 RxJava介绍（一）]]></title>
      <url>%2F2017%2F05%2F12%2FAndroid%E4%B9%8BRxJava%E4%BB%8B%E7%BB%8D%E4%B8%80%2F</url>
      <content type="text"><![CDATA[前言 本篇文章是根据给 Android 开发者的 RxJava 详解做的笔记 主要包含基本概念介绍、线程控制和 ActionX 一、RxJava 是什么一个词概括：异步 RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的 二、为什么要用 RxJava ，好在哪一个词概括：简洁 简洁指的是逻辑的简洁 跟很多做异步的库一样，优势都是简洁，不过它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 三、概念3.1 RxJava 是一种扩展的观察者模式，有四个基本概念 Observable (可观察者，即被观察者) Observer (观察者) subscribe (订阅) 事件 Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 四、创建观察者，即 Observe创建之前要先添加依赖： 123//RxJavacompile &apos;io.reactivex:rxjava:1.3.0&apos;compile &apos;io.reactivex:rxandroid:1.2.1&apos; 4.1 它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式：12345678910111213141516171819/** * 观察者，它决定事件触发的时候将有怎样的行为 */Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; &#125;&#125;; onNext() 是事件回调方法，一般的回调操作逻辑都在这个方法中，也就是说，这个事件触发之后，你想做些什么，实现哪些逻辑 onCompleted()，事件队列完结，RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 4.2 另一个观察者，SubscriberSubscriber 是 Observer 的抽象类，它 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的：12345678910111213141516171819202122Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; &#125; @Override public void onStart() &#123; super.onStart(); &#125; &#125;; 不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 Observable.doOnSubscribe() 方法，关于这个方法后边再介绍 unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 1subscriber.unsubscribe(); 五、创建被观察者 Observable5.1 它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则，create() 方法是 RxJava 最基本的创造事件序列的方法123456789101112131415/** * 创建 被观察者 * * 当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用 */Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;Hello&quot;); subscriber.onNext(&quot;Hi&quot;); subscriber.onNext(&quot;Aloha&quot;); subscriber.onCompleted(); &#125;&#125;); 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 5.2 其他创建 Observable 的方式 just(): 将传入的参数依次发送出来。 1234567//目前，通过 API 发现 just 方法的参数限定在十个以内，十个以外还没试过Observable&lt;String&gt; observable2 = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);// 将会依次调用：// onNext(&quot;Hello&quot;);// onNext(&quot;Hi&quot;);// onNext(&quot;Aloha&quot;);// onCompleted(); from() 将传入的数组或 集合 拆分成具体对象后，依次发送出来。 1234567String[] words = &#123;&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;&#125;;Observable&lt;String&gt; observable3 = Observable.from(words);// 将会依次调用：// onNext(&quot;Hello&quot;);// onNext(&quot;Hi&quot;);// onNext(&quot;Aloha&quot;);// onCompleted(); 12345List&lt;String&gt; items = new ArrayList&lt;&gt;();items.add(&quot;Hello&quot;);items.add(&quot;Hi&quot;);items.add(&quot;Aloha&quot;);Observable&lt;String&gt; observable3 = Observable.from(items); 六、订阅 Subscribe创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单： 123observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 当 subscribe() 方法执行的时候，就立即开始发送事件 七、RxJava 中的 ActionXActionX 指的是一系列的接口，它只有一个方法 call()，这个方法是无返回值的，可以传入 subscribe() 以实现不完整定义的回调。 7.1 看看有多少种 Action 7.2 看看其中的 Action1 和 Action01234567/** * A one-argument action. * @param &lt;T&gt; the first argument type */public interface Action1&lt;T&gt; extends Action &#123; void call(T t);&#125; 123456/** * A zero-argument action. */public interface Action0 extends Action &#123; void call();&#125; 7.3 使用的时候，形式如下12345678910111213141516171819202122232425262728Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, &quot;completed&quot;); &#125;&#125;;// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 说明： Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。 Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1 在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法 由此我们可以看出，观察者的第三种创建方式 八、线程控制 —— Scheduler在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 8.1 Scheduler 的 API 如下： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 8.2 使用我们可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 * observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程，示例如下： 123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.d(tag, &quot;number:&quot; + number); &#125; &#125;); 说明： 上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 Glide 用法简介]]></title>
      <url>%2F2017%2F05%2F11%2FAndroid%E4%B9%8BGlide%E7%94%A8%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[前言本篇主要记录的是 Glide 图片加载框架的使用 一、简介 现在的 Android 网络请求框架比较多，并且功能也很强大，使用起来也很简单，目前大家常用的，说的最多的有三个，分别是 Glide 、Picasso 、 Fresco，各有各的优点，至于选择哪种，完全是看项目需求和个人喜好，可以参考这篇文章 为什么要选择 Glide 呢，第一，是因为这是 Google 官方推荐的网络加载框架，我们做 Android 的，还是尽量以官方为准吧；第二，个人认为简单易用，使用起来很方便。也是唯一一个默认就支持加载 GIF 图片的框架，第三，是内存这块处理的比较好，极大地减少了出现 oom 的几率。当然，这只是个人见解。 郭霖大神有关于 Glide 的详解，请做 飞机 官方关于 Glide 的中文版介绍：https://muzhi1991.gitbooks.io/android-glide-wiki/content/chapter5.html 二、使用 Glide 和 Picasso 在使用上及其方便和快捷，并且两者使用的方式非常相似 第一步：引入依赖包 12//最新的是 3.8 版本的，但是 3.7 目前最稳定 compile &apos;com.github.bumptech.glide:glide:3.8.0&apos; 第二步：添加网络权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt; 第三步：开始在代码中使用 12345678910111213141516Glide .with(this) // 指定Context .load(URL_GIF)// 指定图片的URL .placeholder(R.mipmap.ic_launcher)// 指定图片未成功加载前显示的图片 .error(R.mipmap.ic_launcher)// 指定图片加载失败显示的图片 .override(300, 300)//指定图片的尺寸 .fitCenter()//指定图片缩放类型为fitCenter .centerCrop()// 指定图片缩放类型为centerCrop .skipMemoryCache(true)// 跳过内存缓存 .crossFade(1000)//设置渐变式显示的时间 .diskCacheStrategy(DiskCacheStrategy.NONE)//跳过磁盘缓存 .diskCacheStrategy(DiskCacheStrategy.SOURCE)//仅仅只缓存原来的全分辨率的图像 .diskCacheStrategy(DiskCacheStrategy.RESULT)//仅仅缓存最终的图像 .diskCacheStrategy(DiskCacheStrategy.ALL)//缓存所有版本的图像 .priority(Priority.HIGH)//指定优先级.Glide 将会用他们作为一个准则，并尽可能的处理这些请求，但是它不能保证所有的图片都会按照所要求的顺序加载。优先级排序:IMMEDIATE &gt; HIGH &gt; NORMAL &gt; LOW .into(imageView);//指定显示图片的ImageView 很简单，三步就完成了 三、加载圆形、圆角等图片在我们项目中使用的话，仅仅是上边的简单使用肯定满足不了我们的需求，为了美观，我们需要各种规格的图片 github 上有一个配合 Glide 使用的三方库，就是加载圆形、圆角等图片的 地址为：https://github.com/wasabeef/glide-transformations 简书上有篇文章比较详细的介绍这个库的使用方法：http://www.jianshu.com/p/976c86fa72bc 四、图片加载框架的封装请参考本人的另一篇： https://adsuper.github.io/2017/05/10/Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85/ 也算是偷懒吧，附带了很多链接，而自己少写很多字！实际上也不算是懒，因为这类的文章太多了，经实践，总结的都很好，实在没必要重复造轮子了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 图片加载框架封装]]></title>
      <url>%2F2017%2F05%2F10%2FAndroid%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%E5%B0%81%E8%A3%85%2F</url>
      <content type="text"><![CDATA[前言本篇文章主要介绍的是第三方图片加载框架的封装 一、概述 关于 Android 图片加载框架实在是很多，而且还都很不错，目前主要流行的是 Glide 、 Picasso 、 Fresco，附上一张图，github 上的 star 排名： 其中 Android-Universal-Image-Loader 已经于两年前停止更新了，所以并不推荐使用 二、如何选择2.1 首先，先看下如何选择开源项目 三方链接：帅比张 2.3 图片加载框架对比 关于这方面的东西，网上大把大把的，也都写得不错，我就没必要重复造轮子了 三方链接：帅比张 三、图片加载框架的封装3.1 为什么要封装？ 第三方的框架都已经写的很好了，我们使用起来也很方便，拿 Glide 举个例子 12//一行代码就完成了图片加载Glide.with(this).load(url).into(imageView); 假设个应用场景，随着公司的业务发展，当前的图片加载框架可能满足不了公司的需求了，需要替换一个图片加载框架，如果按上边的那种方式的话，那得该多少代码，花了几天功夫改完之后，领导又说，我觉得还是要之前的那个框架的吧，你什么感觉？？ 不管是为了偷懒，还是为了代码的扩展性，或者是为了应付领导的需求等等，我们都需要再次进行封装。 3.2 如何封装，封装原则是啥 统一接口，一个功能的实现，封装在一个类中，一旦有什么改变，也只需要改变这一个类即可，如： 12345public class ImageLoader &#123; public static void with(Context context, String imageUrl, ImageView imageView) &#123; Picasso.with(context).load(imageUrl).into(imageView); &#125;&#125; 项目中所有需要图片加载功能的地方都这么调用，这样改动起来也很方便。 采用策略模式来封装，根据需求替换不同的图片加载策略即可。 四、具体封装步骤只是简单封装，主要是为了介绍策略模式用我自己的话描述一下吧： 第一步，写一个接口，统一方法名，当然里边也可以有多个方法，可以自己根据需求添加12345678910/** * 图片加载策略 接口 */public interface BaseImageLoaderStrategy &#123; //第一个参数，上下文对象， //第二个参数，是封装的一个类，下边会介绍 void loadImage(Context context,ImageLoader imageLoader);&#125; 第二步，写一个类继承自第一步的接口，并实现具体的加载策略12345678910111213141516/** * 具体的加载策略， Glide 加载框架 */public class GlideImageLoader implements BaseImageLoaderStrategy &#123; @Override public void loadImage(Context context, ImageLoader imageLoader) &#123; Glide.with(context) .load(imageLoader.getUrl()) .placeholder(imageLoader.getPlaceHolder()) .into(imageLoader.getImgView()); &#125;&#125; 第三步，介绍 ImageLoader 类的封装及作用 ImageLoader 类是将常用的网络请求框架所需要的参数封装到一个类中，便于管理 ImageLoader 类的封装，采用的是 Builder 模式，因为参数太多，这样能保证代码的整洁，关于 Builder模式请看：https://adsuper.github.io/2017/05/09/java%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 设置具体的参数，设计为 Builder 模式，方便拆分功能 */public class ImageLoader &#123; private int type; //类型 (大图，中图，小图) private String url; //需要解析的 url private int placeHolder; //当没有成功加载的时候显示的图片 private ImageView imgView; //ImageView 的实例 private int wifiStrategy;//加载策略，是否在 wifi 下才加载 private ImageLoader(Builder builder) &#123; this.type = builder.type; this.url = builder.url; this.placeHolder = builder.placeHolder; this.imgView = builder.imgView; this.wifiStrategy = builder.wifiStrategy; &#125; public int getType() &#123; return type; &#125; public String getUrl() &#123; return url; &#125; public int getPlaceHolder() &#123; return placeHolder; &#125; public ImageView getImgView() &#123; return imgView; &#125; public int getWifiStrategy() &#123; return wifiStrategy; &#125; public static class Builder&#123; private int type; //类型 (大图，中图，小图) private String url; //需要解析的url private int placeHolder; //当没有成功加载的时候显示的图片 private ImageView imgView; //ImageView的实例 private int wifiStrategy;//加载策略，是否在wifi下才载 public Builder() &#123; this.type = ImageLoadreUtils.PIC_SMALL; this.url = &quot;&quot;; this.placeHolder = R.mipmap.ic_launcher; this.imgView = null; this.wifiStrategy = ImageLoadreUtils.LOAD_STRATEGY_NORMAL; &#125; public Builder type(int type) &#123; this.type = type; return this; &#125; public Builder url(String url) &#123; this.url = url; return this; &#125; public Builder placeHolder(int placeHolder) &#123; this.placeHolder = placeHolder; return this; &#125; public Builder imgView(ImageView imgView) &#123; this.imgView = imgView; return this; &#125; public Builder wifiStrategy(int wifiStrategy) &#123; this.wifiStrategy = wifiStrategy; return this; &#125; public ImageLoader bulid()&#123; return new ImageLoader(this); &#125; &#125;&#125; 第四步，策略者，调度者 前边的基础都打好了，后边就该实现策略模式的优点了，看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455** * 图片加载框架 策略模式 * * 设计为单例模式，并且暴露一个方法，可以设置加载模式，使用哪种图片加载框架。 */public class ImageLoadreUtils &#123; //图片类型 public static final int PIC_LARGE = 0;//大图 public static final int PIC_MEDIUM = 1;//中图 public static final int PIC_SMALL = 2;//小图 //是否在 WIFI 下加载 public static final int LOAD_STRATEGY_NORMAL = 0; public static final int LOAD_STRATEGY_ONLY_WIFI = 1; private static ImageLoadreUtils mInstance; private BaseImageLoaderStrategy imageLoaderStrategy; private ImageLoadreUtils() &#123; //默认使用 Glide 加载模式 imageLoaderStrategy = new GlideImageLoader(); &#125; public static ImageLoadreUtils getInstance() &#123; if (mInstance == null) &#123; synchronized (ImageLoadreUtils.class) &#123; if (mInstance == null) &#123; mInstance = new ImageLoadreUtils(); return mInstance; &#125; &#125; &#125; return mInstance; &#125; /** * 设置使用的图片加载框架 * @param imageLoaderStrategy */ public void setImageLoaderStrategy(BaseImageLoaderStrategy imageLoaderStrategy)&#123; this.imageLoaderStrategy = imageLoaderStrategy; &#125; /** * 加载图片 * @param context * @param imageLoader */ public void loadImage(Context context, ImageLoader imageLoader)&#123; imageLoaderStrategy.loadImage(context,imageLoader); &#125; 代码中的注释写的很清楚，这样一来，就算以后想换框架，也只是加代码，而不会改动之前已经调试好的代码。 本文是参考另一篇文章所写，附上链接：http://www.jianshu.com/p/e26130a93289]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java 模式之 Builder 模式]]></title>
      <url>%2F2017%2F05%2F09%2Fjava%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[一、简介 我所认为的 Builder 模式的作用就是为了分解创建复杂对象的过程，如果一个类的成员变量过多，我们要是通过构造函数创建这个类的对象的话，会显得比较臃肿，而且看起来很复杂的样子。我们正常情况下创建对象的过程如下: 123456789101112131415161718192021public class Person &#123; private String name; private int age; private String sex; private String work; private int pay; private int child; private String hobby; public Person(String name, int age, String sex, String work, int pay, int child, String hobby) &#123; this.name = name; this.age = age; this.sex = sex; this.work = work; this.pay = pay; this.child = child; this.hobby = hobby; &#125;&#125; 这个类中七个成员变量，构造方法有七个参数，反正我看到的第一眼就感觉烦，参数太多，看的头晕！ 二、使用 Builder 模式来创建对象 完整的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Person &#123; private String name; private int age; private String sex; private String work; private int pay; private int child; private String hobby; private Person(Builder builder) &#123; this.name = builder.name; this.age = builder.age; this.sex = builder.sex; this.work = builder.work; this.pay = builder.pay; this.child = builder.child; this.hobby = builder.hobby; &#125; public static class Builder&#123; private String name; private int age; private String sex; private String work; private int pay; private int child; private String hobby; public Builder() &#123; this.name = null; this.age = 0; this.sex = null; this.work = null; this.pay = 0; this.child = 0; this.hobby = null; &#125; public Builder name(String name) &#123; this.name = name; return this; &#125; public Builder age(int age) &#123; this.age = age; return this; &#125; public Builder sex(String sex) &#123; this.sex = sex; return this; &#125; public Builder work(String work) &#123; this.work = work; return this; &#125; public Builder pay(int pay) &#123; this.pay = pay; return this; &#125; public Builder child(int child) &#123; this.child = child; return this; &#125; public Builder hobby(String hobby) &#123; this.hobby = hobby; return this; &#125; public Person build()&#123; return new Person(this); &#125; &#125;&#125; 分析： 第一步，先创建一个静态内部类 Builder ，参数与外部类一致 第二步，添加构造函数，设置成员变量的默认值，如果没有特殊的要求不设置也行，因为本身就有默认值。 第三步，改造一系列的 setter 方法，返回值改为 Builder 第四步，修改外部类的构造函数私有化，并且修改参数为 Builder 第五步，添加外部类的一系列 Getter 方法，对外暴露获取成员变量数据的方法，如果不需要不添加也可以。 第六步，添加 build 方法，返回 Person 对象！ 创建对象的过程如下： 12345Person person = new Person.Builder() .age(3) .child(2) .hobby(&quot;吃&quot;) .build(); 这样就把创建对象的过程分离开了，看着也清晰了，并且不用分顺序，好处多多！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DialogFragment 简介]]></title>
      <url>%2F2017%2F05%2F07%2FDialogFragment%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[一、简介DialogFragment 是在 Android 3.0 时引入的，是一种特殊的 Fragment ，用于在 Acticity 上展示一个静态的对话框，如：提示框，输入框，等等 二、DialogFragment 的好处在 DialogFragment 之前，我们一般使用 Dialog 或者 AlertDialog 来创建对话框，包括现在还是很多人以这种方式来创建，但是 Google 并不推荐直接使用 Dialog 创建对话框，而是推荐尽量使用 DialogFragment 来创建，这是因为 DialogFragment 有 Dialog 所没有的一些很好的特性 DialogFragment 是 Fragment 的直接子类，和 Fragment 有着基本一致的声明周期，当屏幕旋转或者按后退键的时候，能更好的管理其生命周期，例如，旋转屏幕时，会导致对话框重新创建，使用 DialogFragment 的话，会由 FragmentManager 自己来重新创建对话框，而 Dialog 则没有这样的功能，必须手动创建。 三、使用 DialogFragment3.1 使用 DialogFragment 至少需要实现 onCreateView() 或者 onCreateDialog() 方法，如下所示1234567891011121314151617181920212223242526272829public class MyDialogFrament extends DialogFragment &#123; /** * 使用定义的xml布局文件展示Dialog。 * * @param inflater * @param container * @param savedInstanceState * @return */ @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; return super.onCreateView(inflater, container, savedInstanceState); &#125; /** * 使用 Dialog 或者 AlertDialog 创建的来展示 * * @param savedInstanceState * @return */ @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; return super.onCreateDialog(savedInstanceState); &#125; 3.2 具体的使用参考：http://blog.csdn.net/lmj623565791/article/details/37815413其实，使用起来还是很简单的，但是仅仅这样使用，并不能显示我们程序员的专业性 0.0 ， 我们要考虑复用性和封装，不想偷懒的程序员不是好程序员！！ 四、封装成通用的 DialogFragment 这有一个哥们写的很不错，github 地址：https://github.com/developerHaoz/DialogFragmentDemos 本人也是分析了大神的思路，觉得很不错，就总结了下来，大概说下封装思路：主要是以 onCreateDialog 的方式来创建对话框，通过回调的形式，从外部传来 AlertDialog 来创建不同类型的提示框。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class MyDialogFrament extends DialogFragment &#123; /** * 使用定义的xml布局文件展示Dialog。 * * @param inflater * @param container * @param savedInstanceState * @return */ @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; return super.onCreateView(inflater, container, savedInstanceState); &#125; /** * 使用 Dialog 或者 AlertDialog 创建的来展示 * 设计为回调接口形式，让调用该接口的人决定显示哪种类型的 Dialog * * @param savedInstanceState * @return */ @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; if (mOnCallDialog == null) &#123; return super.onCreateDialog(savedInstanceState); &#125; return mOnCallDialog.getDialog(getActivity()); &#125; private OnDialogCancelListener mOnDialogCancelListener; /** * 监听弹窗是否被取消 */ public interface OnDialogCancelListener &#123; void onCancel(); &#125; private OnCallDialog mOnCallDialog; /** * 需要显示哪种类型的 DialogFragment */ public interface OnCallDialog &#123; Dialog getDialog(Context context); &#125; /** * 创建 MyDialogFrament 对象 * * @param callDialog Dialog 取消的监听对象 * @param cancelable Dialog 是否可以撤销 * @param cancelListener 需要展示哪种 Dialog 的回调对象 * @return MyDialogFrament 对象 */ public static MyDialogFrament newInstance(OnCallDialog callDialog, boolean cancelable, OnDialogCancelListener cancelListener) &#123; MyDialogFrament instance = new MyDialogFrament(); //控制显示的 Dialog 是否可取消 instance.setCancelable(cancelable); instance.mOnDialogCancelListener = cancelListener; instance.mOnCallDialog = callDialog; return instance; &#125; /** * 创建 MyDialogFrament 对象 * * @param callDialog Dialog 取消的监听对象 * @param cancelable Dialog 是否可以撤销 * @return */ public static MyDialogFrament newInstance(OnCallDialog callDialog, boolean cancelable) &#123; return newInstance(callDialog, cancelable, null); &#125; @Override public void onStart() &#123; super.onStart(); Dialog dialog = getDialog(); if (dialog != null) &#123; // 在 5.0 以下的版本会出现白色背景边框，若在 5.0 以上设置则会造成文字部分的背景也变成透明 if (Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) &#123; // 目前只有这两个 dialog 会出现边框 if (dialog instanceof ProgressDialog || dialog instanceof DatePickerDialog) &#123; getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; &#125; Window window = getDialog().getWindow(); WindowManager.LayoutParams windowParams = window.getAttributes(); windowParams.dimAmount = 0.0f; window.setAttributes(windowParams); &#125; &#125; @Override public void onCancel(DialogInterface dialog) &#123; super.onCancel(dialog); if (mOnDialogCancelListener != null) &#123; mOnDialogCancelListener.onCancel(); &#125; &#125;&#125; 另一个设计点是监听对话框中的所做的操作，可能是选了某一个选项，又或者是点击了确定或取消等，也是以接口回调的形式来做的，可以更加自由的选择在什么地方来对这些操作处理，以其中的一个举例： 接口为： 123public interface IDialogResultListener&lt;T&gt; &#123; void onDataResult(T result);&#125; 以一个列表选项的对话框为例： 123456789101112131415161718192021public static DialogFragment showListDialog(FragmentManager fragmentManager, final String title, final String[] items , final IDialogResultListener&lt;Integer&gt; resultListener, boolean cancelable )&#123; MyDialogFrament dialogFragment = MyDialogFrament.newInstance(new MyDialogFrament.OnCallDialog() &#123; @Override public Dialog getDialog(Context context) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context, LIST_THEME); builder.setTitle(title); builder.setItems(items, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; if(resultListener != null)&#123; resultListener.onDataResult(which); &#125; &#125; &#125;); return builder.create(); &#125; &#125;, cancelable, null); dialogFragment.show(fragmentManager, LIST_TAG); return null;&#125; 其中，列表的点击事件激活此回调接口，使用者，可以在需要的时候实现该接口，并且经过这一层的封装，代码看起来也更简洁，可读性更强！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 下拉刷新之 SwipeRefreshLayout]]></title>
      <url>%2F2017%2F05%2F05%2FAndroid%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E4%B9%8BSwipeRefreshLayout%2F</url>
      <content type="text"><![CDATA[一、简介 SwipeRefreshLayout 是 Google 官方提供的一个下拉刷新的控件。 注意包的位置：android.support.v4.widget.SwipeRefreshLayout 二、使用 用法很简单，将需要下拉刷新功能的控件放在 SwipeRefreshLayout 中，注意，SwipeRefreshLayout 只能有一个子控件。 2.1 xml 布局文件如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;!--标题栏--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;FloatingActionButton&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; 指定一个布局行为--&gt; &lt;!--下拉刷新控件 SwipeRefreshLayout--&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/swiperefreshlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;!--RecyclerView--&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@id/toolbar&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;!--FloatingActionButton--&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; app:fabSize=&quot;normal&quot; app:pressedTranslationZ=&quot;10dp&quot; app:rippleColor=&quot;@color/colorAccent&quot; /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/RelativeLayout&gt; 可以看到，SwipeRefreshLayout 中包裹了一个 RecyclerView ，也就是说，RecyclerView 是需要下拉刷新的控件。 2.2 代码中还有一些设置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MyRecyclerViewActivity extends AppCompatActivity &#123; @BindView(R.id.floating) FloatingActionButton floating; @BindView(R.id.toolbar_title) TextView toolbarTitle; @BindView(R.id.toolbar) Toolbar toolbar; @BindView(R.id.recycler_view) RecyclerView recyclerView; @BindView(R.id.swiperefreshlayout) SwipeRefreshLayout swiperefreshlayout; private Snackbar snackbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recyclerview_appbarlayout); ButterKnife.bind(this); //设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar); toolbar.setNavigationIcon(R.drawable.setting); initRecyclerViewData(); initRcyclerView(); initSwipeRefreshLayout(); &#125; /** * 初始化下拉刷新控件，SwipeRefreshLayout */ private void initSwipeRefreshLayout() &#123; //设置刷新进度条的颜色变化，最多可以设置 4 种，加载的颜色是循环播放的。 swiperefreshlayout.setColorSchemeResources(R.color.colorAccent); //设置手指在屏幕上下拉多少会触发下拉刷新 swiperefreshlayout.setDistanceToTriggerSync(300); //设置下拉刷新的圆圈背景颜色 swiperefreshlayout.setProgressBackgroundColorSchemeColor(Color.WHITE); //设置下拉刷新的圆圈大小 swiperefreshlayout.setSize(SwipeRefreshLayout.DEFAULT); // 设置刷新时候的监听事件 swiperefreshlayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; //执行刷新之后的操作，一般都是联网请求数据 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; initData(); myRecyclerAdapter.notifyDataSetChanged(); //停止刷新 swiperefreshlayout.setRefreshing(false); &#125; private void initData() &#123; listData.add(&quot;我是刷新时候添加的数据&quot;); listData.add(&quot;我是刷新时候添加的数据&quot;); listData.add(&quot;我是刷新时候添加的数据&quot;); listData.add(&quot;我是刷新时候添加的数据&quot;); &#125; &#125;); &#125; &#125;).start(); &#125; &#125;); 2.3 运行效果如下： 三、添加上拉加载更多思路： 利用 RecyclerView 的 addOnScrollListener 方法，自己动手实现滑动监听，当屏幕可见的最后一条条目显示出来的时候，实现加载更多的逻辑。 3.1 Activity 中使用时的代码：123456789//上拉加载更多 recyclerView.addOnScrollListener(new MyRecyclerViewOnScrollListener(linearLayoutManager) &#123; @Override public void loadMoreDate() &#123; listData.add(&quot;我是上拉加载时候添加的数据&quot;); listData.add(&quot;我是上拉加载时候添加的数据&quot;); myRecyclerAdapter.notifyDataSetChanged(); &#125; &#125;); 3.2 MyRecyclerViewOnScrollListener 中的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * RecyclerView 滑动监听，目的：实现上拉加载更过多 */public abstract class MyRecyclerViewOnScrollListener extends RecyclerView.OnScrollListener &#123; private LinearLayoutManager linearLayoutManager; //屏幕上可见的 item 数量 private int visibleItemCount; //已经加载出来的 item 数量 private int totalItemCount; //屏幕上可见的第一个 item private int firstVisibleItem; //是否正在上拉加载数据中 private boolean isLoadingMore = false; //记录之前的数据总数 private int agoneTotle; public MyRecyclerViewOnScrollListener(LinearLayoutManager linearLayoutManager) &#123; this.linearLayoutManager = linearLayoutManager; &#125; /** * 滑动状态改变 * * @param recyclerView 当前滚动的 RecyclerView * @param newState 当前滚动的状态，有三个值 * public static final int SCROLL_STATE_IDLE = 0;静止没滚动 * public static final int SCROLL_STATE_DRAGGING = 1;用户正在用手指滚动 * public static final int SCROLL_STATE_SETTLING = 2;自动滚动 */ @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); &#125; /** * 正在滑动 * * @param recyclerView 当前滚动的 RecyclerView * @param dx 水平滚动距离 * @param dy 垂直滚动距离 * dx &gt; 0 时为手指向左滚动,列表滚动显示右面的内容 * dx &lt; 0 时为手指向右滚动,列表滚动显示左面的内容 * dy &gt; 0 时为手指向上滚动,列表滚动显示下面的内容 * dy &lt; 0 时为手指向下滚动,列表滚动显示上面的内容 */ @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); //向下滑动 if (dy &gt; 0) &#123; visibleItemCount = linearLayoutManager.getChildCount(); totalItemCount = linearLayoutManager.getItemCount(); firstVisibleItem = linearLayoutManager.findFirstVisibleItemPosition(); &#125; //如果正在加载中 if(isLoadingMore)&#123; //说明加载结束 if(totalItemCount &gt; agoneTotle)&#123; isLoadingMore = false; agoneTotle = totalItemCount; &#125; &#125; //如果没有正在加载中，并且，当前屏幕上可见 item 的总数 + 屏幕上可见第一条 item 大于等于 目前加载出来的数据总数 if (!isLoadingMore &amp;&amp; (visibleItemCount + firstVisibleItem) &gt;= totalItemCount) &#123; isLoadingMore = true; //加载更多数据，设置一个抽象方法来实现具体的加载逻辑 loadMoreDate(); &#125; &#125; public abstract void loadMoreDate();&#125; 这种实现方式没有实现加载时的加载过程，用户感知不到！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 AppBarLayout]]></title>
      <url>%2F2017%2F05%2F05%2FAndroid%E4%B9%8BAppBarLayout%2F</url>
      <content type="text"><![CDATA[一、简介 AppBarLayout 是 Design Support 库中提供的一个控件，它是一个垂直方向的 LinearLayout ，它的内部做了很多滚动事件的封装，并应用了一些 Material Design 的设计理念！ 二、简单使用 AppBarLayout 一般是配合 CoordinatorLayout 来使用，实现一些 Material Design 效果，CoordinatorLayout 是一个加强版的 FrameLayout，在 CoordinatorLayout 下添加控件会出现覆盖的情况，因为 FrameLayout 默认都是从屏幕的左上角开始添加控件，如果加上 AppBarLayout 的话，就会避免这种覆盖的情况，并实现一些 Material Design 效果！ 2.1 添加 Design Support 的依赖12345678910dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) compile &apos;com.android.support:appcompat-v7:25.3.1&apos; compile &apos;com.android.support:design:25.3.1&apos; &#125; 2.2 使用 CoodinatorLayout 而不使用 AppBarLayout 的情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--标题栏--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;FloatingActionButton&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;!--RecyclerView--&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@id/toolbar&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt; &lt;!--FloatingActionButton--&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; app:fabSize=&quot;normal&quot; app:pressedTranslationZ=&quot;10dp&quot; app:rippleColor=&quot;@color/colorAccent&quot; /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/RelativeLayout&gt; 运行结果如下： 发现: RecyclerView 将 Toolbar 覆盖掉了，而且也很难看，这时候就需要 AppBarLayout 来协调这些个关系 2.3 CooldinatorLayout 和 AppBarLayout 配合使用 在布局文件中，将 Toolbar 包裹在 AppBarlayout 之内，并给 RecyclerView 指定个布局行为 修改后的布局文件如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;!--标题栏--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;FloatingActionButton&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; 指定一个布局行为--&gt; &lt;!--RecyclerView--&gt; &lt;android.support.v7.widget.RecyclerView app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_below=&quot;@id/toolbar&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt; &lt;!--FloatingActionButton--&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; app:fabSize=&quot;normal&quot; app:pressedTranslationZ=&quot;10dp&quot; app:rippleColor=&quot;@color/colorAccent&quot; /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/RelativeLayout&gt; 运行结果如下 显示结果正常 2.4 添加 Material Design 效果 2.4.1 当 AppBarLayout 收到滚动事件的时候，它内部的子控件是可以指定如何去影响这些事件的，其实就是在 Toolbar 中添加一条属性：app:layout_scrollFlags ，一共有五个 Flag 可选，在这里常用的有三个 scroll 表示向上滚动时，toolbar 会跟着一起向上滚动并隐藏 enterAlways 表示向下滚动时，toolbar 会跟着一起向下滚动并重新显示 snap 表示当 toolbar 还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择隐藏或者显示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可折叠式标题栏 - CollapsingToolbarLayout]]></title>
      <url>%2F2017%2F05%2F05%2F%E5%8F%AF%E6%8A%98%E5%8F%A0%E5%BC%8F%E6%A0%87%E9%A2%98%E6%A0%8F-CollapsingToolbarLayout%2F</url>
      <content type="text"><![CDATA[一、简介 我们现在的标题栏基本都是使用 Toolbar 来实现的，但是并没有规定标题栏的样式，我们可以根据自己的喜好来实现不同样式的标题栏。 CollapsingToolbarLayout 是一个作用于 Toolbar 基础之上的布局，它可以让 Toolbar 的效果变得更加绚丽。本次实现一个可折叠式标题栏 二、可折叠式标题栏的实现注意： CollapsingToolbarLayout 是不能独立存在的，它只能作为 AppBarLayout 的直接子布局来使用，而 AppBarLayout 必须是 CoordinateLayout 的子布局，所以我们就用 CoordinateLayout 作为最外层布局样式 2.1 页面的布局文件如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbarlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsingtoolbarlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:contentScrim=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--app:layout_collapseMode=&quot;parallax&quot;,指定当前控件在折叠过程中的折叠模式--&gt; &lt;ImageView android:id=&quot;@+id/imageview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;!--标题栏--&gt; &lt;!--app:layout_collapseMode=&quot;pin&quot;，表示折叠过程中位置始终保持不变--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!--NestedScrollView 内部只允许有一个子布局--&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; &gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.CardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;15dp&quot; android:layout_marginTop=&quot;35dp&quot; app:cardCornerRadius=&quot;4dp&quot;&gt; &lt;TextView android:id=&quot;@+id/textview_card&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; /&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; &lt;!--FloatingActionButton--&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; app:fabSize=&quot;normal&quot; app:layout_anchor=&quot;@id/appbarlayout&quot; app:layout_anchorGravity=&quot;bottom|end&quot; app:pressedTranslationZ=&quot;10dp&quot; app:rippleColor=&quot;@color/colorAccent&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局分析： 最外层是 CooldinatorLayout，其下有三个直接子布局，分别是 AppBarLayout 、NestedScrollView 、 FloatingActionButton AppBarLayout 下有一个直接子布局 CollapsingToolbarLayout ，其下有两个控件，ImageView 和 Toolbar 1234567&lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbarlayout&quot; android:layout_width=&quot;match_parent&quot; // 250 dp 视觉效果好，当然并不是固定的 android:layout_height=&quot;250dp&quot; //是为了状态栏的适配 android:fitsSystemWindows=&quot;true&quot;&gt; 12345678910111213&lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/collapsingtoolbarlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; //这个主题本来是给 Toolbar 的，为了实现效果放到父布局中了 android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; //设置 趋于折叠以及折叠之后的颜色 app:contentScrim=&quot;@color/colorPrimary&quot; //scroll 表示标题栏会跟着下方的 NestedScrollView 一起滚动 //exitUntilCollapsed 表示折叠之后，标题栏保留在界面上，而不是移出屏幕 app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; //这个主题也是给 toolbar 设置的 app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; 1234567891011121314&lt;ImageView android:id=&quot;@+id/imageview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; //指定折叠模式， parallax 表示折叠过程中会产生一定的错位偏移，视觉效果好 app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;!--标题栏--&gt; &lt;!--app:layout_collapseMode=&quot;pin&quot;，表示折叠过程中位置始终保持不变--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt; NestedScrollView 也是要求只能有一个直接子布局，要想放东西多，就在外层加个大布局。 FloatingActionButton 属性介绍 12345678910111213&lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; app:fabSize=&quot;normal&quot; //设定一个锚点，意思就是 FloatingActionButton 会显示在 appbarlayout 中 app:layout_anchor=&quot;@id/appbarlayout&quot; //将悬浮按钮定位在标题栏区域的右下角 app:layout_anchorGravity=&quot;bottom|end&quot; app:pressedTranslationZ=&quot;10dp&quot; app:rippleColor=&quot;@color/colorAccent&quot; /&gt; 2.2 对应的 Activity 中的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MyRecyclerViewItemDetailActivity extends AppCompatActivity &#123; @BindView(R.id.imageview) ImageView imageview; @BindView(R.id.toolbar) Toolbar toolbar; @BindView(R.id.collapsingtoolbarlayout) CollapsingToolbarLayout collapsingtoolbarlayout; @BindView(R.id.appbarlayout) AppBarLayout appbarlayout; @BindView(R.id.textview_card) TextView textviewCard; @BindView(R.id.floating) FloatingActionButton floating; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my_recycler_view_item_detail); ButterKnife.bind(this); Intent intent = getIntent(); String titleName = intent.getStringExtra(&quot;titleName&quot;); //设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; setSupportActionBar(toolbar); ActionBar actionBar = getSupportActionBar(); if (actionBar != null) &#123; //显示标题栏左侧导航图标 actionBar.setDisplayHomeAsUpEnabled(true); &#125; actionBar.setTitle(titleName);// imageview.setImageResource(R.drawable.cardview_icon); Glide.with(this).load(R.drawable.cardview_icon).into(imageview); textviewCard.setText(ContentData(titleName)); &#125; /** * 虚构的 TextView 要显示的数据 * @param titleName * @return */ private String ContentData(String titleName) &#123; StringBuffer buffer = new StringBuffer(); for (int i = 0;i &lt; 500;i++)&#123; buffer.append(titleName); &#125; return buffer.toString(); &#125;&#125; 说明： 设置的逻辑是，一个 RecyclerView 的条目点击事件，通过 Intent 传递数据到这个页面，然后展示对应的条目详情。 2.3 显示效果如下所示：设备： Android 4.4]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView 简介及点击事件处理]]></title>
      <url>%2F2017%2F05%2F04%2FRecyclerView%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[一、简介： RecyclerView 是 Android5.0 之后新出的控件。 RecyclerView 是 ListView 的增强版，不仅能实现 ListView 的效果，还优化了 ListView 的很多不足之处。 想对于 ListView 来说，官方更推荐使用 RecyclerView 二、使用 RecyclerView 演示思路：布局 RecyclerView ，CardView 充当其 Item ！ 2.1 app 的 build.gradle 中添加依赖123// cardview 是因为这个 Demo 也要用到 cardviewcompile &apos;com.android.support:cardview-v7:25.3.1&apos;compile &apos;com.android.support:recyclerview-v7:25.3.1&apos; 2.2 主页面布局文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题栏--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;FloatingActionButton&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;!--RecyclerView--&gt; &lt;android.support.v7.widget.RecyclerView android:layout_below=&quot;@id/toolbar&quot; android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/android.support.v7.widget.RecyclerView&gt; &lt;!--FloatingActionButton--&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_alignBottom=&quot;@id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; app:fabSize=&quot;normal&quot; app:pressedTranslationZ=&quot;10dp&quot; app:rippleColor=&quot;@color/colorAccent&quot; /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/RelativeLayout&gt; 2.3 Actiity 和 Adapter 的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class MyRecyclerViewActivity extends AppCompatActivity &#123; @BindView(R.id.floating) FloatingActionButton floating; @BindView(R.id.toolbar_title) TextView toolbarTitle; @BindView(R.id.toolbar) Toolbar toolbar; @BindView(R.id.recycler_view) RecyclerView recyclerView; private Snackbar snackbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycleview); ButterKnife.bind(this); //设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar); toolbar.setNavigationIcon(R.drawable.setting); initRecyclerViewData(); initRcyclerView(); &#125; private void initRcyclerView() &#123; LinearLayoutManager manager = new LinearLayoutManager(this);// GridLayoutManager manager = new GridLayoutManager(getApplicationContext(),2);// StaggeredGridLayoutManager manager = new StaggeredGridLayoutManager(2, OrientationHelper.HORIZONTAL); recyclerView.setLayoutManager(manager); myRecyclerAdapter = new MyRecyclerAdapter(); recyclerView.setAdapter(myRecyclerAdapter); &#125; private List&lt;String&gt; listData; /** * 初始化 RecyclerView 的数据 */ private void initRecyclerViewData() &#123; listData = new ArrayList&lt;&gt;(); int m = 0; for (int i = 0; i &lt; 20; i++) &#123; listData.add(&quot;珞璃之神&quot; + m); m++; &#125; &#125; private MyRecyclerAdapter myRecyclerAdapter; public class MyRecyclerAdapter extends RecyclerView.Adapter&lt;MyRecyclerAdapter.ViewHolder&gt; &#123; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.activity_card_view, parent, false);// View view = View.inflate(getApplicationContext(), R.layout.activity_card_view, parent); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.cardText.setText(listData.get(position)); &#125; @Override public int getItemCount() &#123; return listData.size(); &#125; public class ViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.card_text) TextView cardText; @BindView(R.id.card_image) ImageView cardImage; public ViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); &#125; &#125; &#125;&#125; 注意： RecyclerView 的三种 manager ，分别为 线性、宫格、瀑布流样式。 2.4 RecyclerView 的 item 的样式为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;@dimen/cardview_margin&quot; android:layout_marginTop=&quot;@dimen/cardview_margin&quot; android:layout_marginLeft=&quot;@dimen/cardview_margin_left_right&quot; android:layout_marginRight=&quot;@dimen/cardview_margin_left_right&quot; app:cardCornerRadius=&quot;5dp&quot; android:foreground=&quot;?android:attr/selectableItemBackground&quot; app:cardElevation=&quot;10dp&quot;&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:layout_weight=&quot;5&quot; android:id=&quot;@+id/card_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/cardview_icon&quot; /&gt; &lt;TextView android:layout_weight=&quot;1&quot; android:id=&quot;@+id/card_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;0dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_below=&quot;@id/card_image&quot; android:text=&quot;珞神&quot; android:textColor=&quot;#ba2f2f&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 2.5 运行结果如下： LinearLayoutManager manager = new LinearLayoutManager(this); 结果： GridLayoutManager manager = new GridLayoutManager(getApplicationContext(),2);结果如下： StaggeredGridLayoutManager manager = new StaggeredGridLayoutManager(2, OrientationHelper.HORIZONTAL);结果如下： 三、RecyclerView 添加条目点击事件3.1 RecyclerView 并没有对外暴露的具体的单击或长按监听事件，需要我们自己来处理单击或长按事件，如下所示：123456789101112131415161718recyclerView.addOnItemTouchListener(new RecyclerView.OnItemTouchListener()&#123; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; return false; &#125; @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123; &#125; @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; &#125;&#125;); 这种需要自己增加单击或长按事件的逻辑，然后利用接口回调出去。 Android 给我们提供了一个手势监测帮助类 GestureDetector ，我们可以借助这个类来处理不同的手势，我们重新建个类实现 RecyclerView.OnItemTouchListener 接口。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 自定义手势监听 */public class RecyclerViewClickListener implements RecyclerView.OnItemTouchListener &#123; // GestureDetectorCompat 是为了版本兼容 private GestureDetectorCompat mGestureDetector; private OnItem2ClickListener mListener; //自定义内部监听 public interface OnItem2ClickListener &#123; //单击 void onItemClick(View view, int position); //长按 void onItemLongClick(View view, int position); &#125; public RecyclerViewClickListener(Context context, final RecyclerView mRecyclerView, OnItem2ClickListener listener) &#123; this.mListener = listener; // SimpleOnGestureListener 是为了选择重写需要的方法 mGestureDetector = new GestureDetectorCompat(context, new GestureDetector.SimpleOnGestureListener() &#123; //单击事件 @Override public boolean onSingleTapUp(MotionEvent e) &#123; Log.i(&quot;mGestureDetector&quot;,&quot;onSingleTapUp&quot;); View childViewUnder = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (childViewUnder != null &amp;&amp; mListener != null) &#123; mListener.onItemClick(childViewUnder, mRecyclerView.getChildLayoutPosition(childViewUnder)); return true; &#125; return false; &#125; //长按事件 @Override public void onLongPress(MotionEvent e) &#123; Log.i(&quot;mGestureDetector&quot;,&quot;onLongPress&quot;); View childView = mRecyclerView.findChildViewUnder(e.getX(),e.getY()); if(childView != null &amp;&amp; mListener != null)&#123; mListener.onItemLongClick(childView,mRecyclerView.getChildLayoutPosition(childView)); &#125; &#125; &#125;); &#125; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; //是否拦截事件交给 mGestureDetector 处理 if(mGestureDetector.onTouchEvent(e))&#123; return true; &#125;else return false; &#125; @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123; &#125; @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; &#125;&#125; 代码中只实现了，单击和长按事件的回调，更多的事件操作方法可以参考 GestureDetector 类。 3.2 另一种方式是在 Adapter 的 onBindViewHolder 方法中，利用 View 本身的监听事件，来设置回调监听，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MyRecyclerAdapter extends RecyclerView.Adapter&lt;MyRecyclerAdapter.ViewHolder&gt; &#123; private List&lt;String&gt; listData; public MyRecyclerAdapter(List&lt;String&gt; listData)&#123; this.listData = listData; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.activity_card_view, parent, false);// View view = View.inflate(getApplicationContext(), R.layout.activity_card_view, parent); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; /** * 在 onBindViewHolder 中，设置单击和长按的监听回调 * @param holder * @param position */ @Override public void onBindViewHolder(final ViewHolder holder, final int position) &#123; holder.cardText.setText(listData.get(position)); //单击 holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //触发自定义监听的单击事件 onItemClickListener.onItemClick(holder.itemView,position); &#125; &#125;); //长按 holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; //触发自定义监听的长按事件 onItemClickListener.onItemLongClick(holder.itemView,position); return true;//表示此事件已经消费，不会触发单击事件 &#125; &#125;); &#125; @Override public int getItemCount() &#123; return listData.size(); &#125; public class ViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.card_text) TextView cardText; @BindView(R.id.card_image) ImageView cardImage; public ViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); &#125; &#125; public void setOnItemClickListener(MyRecyclerAdapter.OnItemClickListener onItemClickListener)&#123; this.onItemClickListener = onItemClickListener; &#125; private OnItemClickListener onItemClickListener; /** * 自定义监听回调，RecyclerView 的 单击和长按事件 */ public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125;&#125; 3.3 两种添加点击事件比较 第一种方式更加灵活，解耦性更高，第二种因为设置在 Adapter 内，只能用作特定的 RecyclerView 第二种相对第一种来说，更加简便，实现起来也方便，也比较好理解。 第一种还能用于更加复杂的手势监听，我们可以利用 GestureDetector 类来实现更加复杂的事件监听回调，而第二种监听的事件比较有限。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CardView 简介]]></title>
      <url>%2F2017%2F05%2F04%2FCardView%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[一、简介 CardView 是卡片式布局的控件，继承自 FrameLayout ，不过提供了一些属性，如圆角、阴影效果等，使其具有立体感，有种卡片的感觉。 二、使用 使用比较简单，可以当成 FrameLayout 使用，不过需要添加一些立体感的属性 需要添加依赖： 12//版本与 V7 包一致compile &apos;com.android.support:cardview-v7:25.3.1&apos; 2.1 在 xml 中简单使用如下所示：1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:cardBackgroundColor=&quot;@color/colorAccent&quot; app:cardCornerRadius=&quot;5dp&quot; app:cardElevation=&quot;10dp&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/card_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;TextView android:id=&quot;@+id/card_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_marginLeft=&quot;50dp&quot; android:layout_toRightOf=&quot;@id/card_image&quot; android:text=&quot;珞神&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;/RelativeLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 由于 CardView 本身是个 FrameLayout ，所以指定一个 RelativeLayout 作为它的布局方式。 app:cardBackgroundColor=”@color/colorAccent” 设置背景色 app:cardCornerRadius=”5dp” 设置圆角弧度半径，值越大，圆角越大 app:cardElevation=”10dp” 设置阴影高度，值越大，阴影效果越明显 三、 CardView 的其他用途 CardView 单独作为布局用的很少，一般是作为 ListView 或者 RecyclerView 的条目填充布局使用。 3.1 在配合 RecyclerView 使用的时候，Android5.0 以前版本和以后版本的显示效果不同，需要做 demins 适配，先看下效果。 RecyclerView 的 item 布局如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:cardCornerRadius=&quot;5dp&quot; android:foreground=&quot;?android:attr/selectableItemBackground&quot; app:cardBackgroundColor=&quot;@color/colorAccent&quot; app:cardElevation=&quot;10dp&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/card_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;TextView android:id=&quot;@+id/card_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_marginLeft=&quot;50dp&quot; android:layout_toRightOf=&quot;@id/card_image&quot; android:text=&quot;珞神&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;/RelativeLayout&gt;&lt;/android.support.v7.widget.CardView&gt; Android 7.0 手机显示如下： Android 4.4 手机显示如下： 可以看到，4.4 每个条目之间有很大的空隙，供阴影显示，而 7.0 是仅仅的挤在一块，如果设置 margin 属性增大空隙后，4.4 上的空隙会继续加大 解决办法： dimens 适配，创建一个 value-v21 文件夹，在其下创建一个 dimens.xml 文件，分别设置不同的 dp 值。 values 中的 dimens.xml如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;cardview_margin&quot; &gt;0dp&lt;/dimen&gt; &lt;dimen name=&quot;cardview_margin_left_right&quot; &gt;0dp&lt;/dimen&gt;&lt;/resources&gt; values-v21 中的 dimens.xml如下： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;dimen name=&quot;cardview_margin&quot; &gt;14dp&lt;/dimen&gt; &lt;dimen name=&quot;cardview_margin_left_right&quot; &gt;10dp&lt;/dimen&gt;&lt;/resources&gt; 然后在 Cardv 中添加 margin 属性 1234android:layout_marginBottom=&quot;@dimen/cardview_margin&quot;android:layout_marginTop=&quot;@dimen/cardview_margin&quot;android:layout_marginLeft=&quot;@dimen/cardview_margin_left_right&quot;android:layout_marginRight=&quot;@dimen/cardview_margin_left_right&quot; 系统会自动选择对应的值，这样就完成了 dimens 适配 注意： CardView 官方不建议 app 中多处使用，只有在一些比较突出的地方使用即可。 四、CardView 添加水波纹点击效果 需要在 CardView 下添加如下代码： 12android:clickable=&quot;true&quot;android:foreground=&quot;?android:attr/selectableItemBackground&quot; 不过在 5.0 以上显示效果正常，在 5.0 以下显示为 灰色阴影加深或其他的效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment 的 startActivityForResult()]]></title>
      <url>%2F2017%2F04%2F26%2FFragment%E7%9A%84startActivityForResult%2F</url>
      <content type="text"><![CDATA[一、为什么要写 startActivityForResult() 在实际项目中我们会有这样的应用场景，在 Activity1 的 Fragment1 中的某个点击事件，跳转到另一个 Activity2 的 Fragment2 中，而 Fragment2 需要返回一些数据给 Fragment1，这时候我们该怎么办呢 通过 Fragment 的 startActivityForResult() 方法可以完成上述的操作，但是这又跟我们平时的 Activity 的 startActivityForResult() 不一样， Fragment 没有 setResult() 方法，无法设置返回的数据。 正确的操作思路是：Fragment1 调用 startActivityForResult() 方法之后，跳转到 Activity2 中，Activity2 先把数据取出来，然后通过 Bundle 把数据设置给 Fragment2 ，Fragment2 把数据取出来，然后调用 getActivity().setResult() 方法设置返回数据，然后在 Fragment1 的 onActivityResult() 中拿到返回的数据 二、实际操作2.1 Fragment1，即 FirstFragment 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class FirstFragment extends Fragment &#123; @BindView(R.id.listview) ListView listview; private String name; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; Log.i(&quot;FirstFragment&quot;, &quot;onCreateView&quot;); View inflate = inflater.inflate(R.layout.huituizhan_first_fragment, container, false); ButterKnife.bind(this, inflate); initListViewData(); return inflate; &#125; private void initListViewData() &#123; list = new ArrayList&lt;&gt;(); int m = 0; for (int i = 0; i &lt; 20; i++) &#123; list.add(&quot;珞神&quot;+m); m++; &#125; myAdapter = new MyAdapter(); listview.setAdapter(myAdapter); listview.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; //点击跳转 Intent intent = new Intent(getActivity(),ResultActivity.class); intent.putExtra(&quot;item&quot;,position+&quot;&quot;); startActivityForResult(intent,0); &#125; &#125;); &#125; /** * 调用 startActivityForResult 后，目标activity 返回的数据会在这个方法内 * @param requestCode * @param resultCode * @param data */ @Override public void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); list.add(requestCode+resultCode+data.getStringExtra(&quot;item&quot;)); myAdapter.notifyDataSetChanged(); &#125; private ArrayList&lt;String&gt; list; private MyAdapter myAdapter; public class MyAdapter extends BaseAdapter &#123; @Override public int getCount() &#123; return list.size(); &#125; @Override public Object getItem(int position) &#123; return list.get(position); &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; View view = null; ViewHolder viewHolder; if (convertView == null) &#123; view = View.inflate(getActivity(), R.layout.litt_item, null); viewHolder = new ViewHolder(view); view.setTag(viewHolder); &#125;else &#123; view = convertView; viewHolder = (ViewHolder) view.getTag(); &#125; viewHolder.listText.setText(list.get(position)); return view; &#125; &#125; static class ViewHolder &#123; @BindView(R.id.list_text) TextView listText; ViewHolder(View view) &#123; ButterKnife.bind(this, view); &#125; &#125;&#125; 2.2 Activity2 即 ResultActivity 的代码如下：12345678910111213141516171819202122232425262728public class ResultActivity extends AppCompatActivity &#123; @BindView(R.id.framelayout_resultfragment) FrameLayout framelayoutResultfragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_sencond); ButterKnife.bind(this); //取出传递过来的数据， 注意 newInstance 方法设置的有 Bundle String title = getIntent().getStringExtra(&quot;item&quot;); ResultFragment resultFragment = ResultFragment.newInstance(title); getSupportFragmentManager() .beginTransaction() .add(R.id.framelayout_resultfragment,resultFragment,&quot;resultfragment&quot;) .commit(); &#125;&#125; 注意：ResultFragment 一定要是同一个对象，不要创建两个对象 2.3 Fragment2 即 ResultFragment 的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.administrator.fragment_text.huituizhan;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.Fragment;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.example.administrator.fragment_text.R;public class ResultFragment extends Fragment &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Bundle bundle = getArguments(); if (bundle != null) &#123; String item = bundle.getString(&quot;item&quot;); Log.i(&quot;ResultFragment&quot;,item+&quot;&quot;); Intent intent = new Intent(); intent.putExtra(&quot;item&quot;,&quot;result&quot;); getActivity().setResult(1,intent); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment return inflater.inflate(R.layout.fragment_result, container, false); &#125; //返回 resultFragment 对象，并把传递过来的数据设置在 bundle 中 public static ResultFragment newInstance(String argument)&#123; Bundle bundle = new Bundle(); bundle.putString(&quot;item&quot;, argument); ResultFragment resultFragment = new ResultFragment(); resultFragment.setArguments(bundle); return resultFragment; &#125;&#125; 注意： 这里的逻辑是，在创建 ResultFragment 对象的时候，就把数据设置进 Bundle 中了，然后在 onCreate 方法中取出 bundle 中的数据，并设置返回的数据。 2.4 然后在 FirstFragment 中的 onActivityResult() 中 根据 resultCode 取回数据进行操作！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 Snackbar]]></title>
      <url>%2F2017%2F04%2F25%2FAndroid%E4%B9%8BSnackbar%2F</url>
      <content type="text"><![CDATA[一、简介 Snackbar 是 Android 5.0 之后新出的一个控件，属于 com.android.support:design 包下 Snackbar 并不是 Toast 的替代品，两者各有不同的应用场景，只不过是 Snackbar 对 Toast 进行了扩展，允许在提示当中加入一个可交互按钮 二、简单使用2.1 要先在 app 的 build.gradle 中添加依赖12//个人认为与 V7 包的版本一致最好 compile &apos;com.android.support:design:25.3.1&apos; 2.2 简单操作如下1Snackbar.make(view,&quot;我是Snackbar&quot;,Snackbar.LENGTH_LONG).show(); 第一个参数是 view ，只要传入当前界面布局的任意一个 view 都可以，它会根据这个 view 来查找最外层的布局，用于确定 Snackbar 的位置，但是如果在找的过程中，找到 CoordinatorLayout ，那就会认为 CoordinatorLayout 为最外层布局 第二个参数是 String ，即：提示的信息 第三个参数是 显示多长时间的意思，有三个可选参数 123Snackbar.LENGTH_SHORT //事件短，大概 1.8 秒左右Snackbar.LENGTH_LONG // 时间长，大概 3 秒左右Snackbar.LENGTH_INDEFINITE // 永久显示，需手动取消 显示效果如下：注意：我这里的最外层布局为 LinearLayout ，如果换成 CoordinatorLayout 就不会覆盖掉了 2.3 添加可交互按钮1234567Snackbar.make(view,&quot;我是Snackbar&quot;,Snackbar.LENGTH_LONG) .setAction(&quot;按钮&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;).show(); 通过 setAction 添加按钮，默认只要点击 Snackbar 就消失 第一个参数：按钮显示的文字 第二个参数：点击监听 显示效果如下： 三、主要注意的几点： 只有最外层的布局为 CoordinatorLayout ，Snackbar 才不会覆盖掉 FloatingActionButton 。 只有 Snackbar 配合 CoordinatorLayout 使用，才会有侧滑删除的动画效果，否则是没有的。 Google 设计规范要求1，Snackbar 只以纯文本的形式来显示 Google 设计规范要求2，同一个屏幕中最多只能同时出现一个 Snackbar。 四、玩转 Snackbar4.1 修改 Snackbar 右侧可点击按钮的颜色12345678910snackbar = Snackbar.make(view,&quot;我是Snackbar&quot;,Snackbar.LENGTH_LONG) .setAction(&quot;按钮&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);snackbar.show();// 修改 Snackbar 右侧可点击按钮的颜色snackbar.setActionTextColor(Color.WHITE); 运行效果如下 4.2 修改背景色 和 Snackbar 左侧文字显示颜色 Snackbar 源码中的布局文件为： 12345678910111213141516171819202122232425262728293031&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;TextView android:id=&quot;@+id/snackbar_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:paddingTop=&quot;14dp&quot; android:paddingBottom=&quot;14dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:textAppearance=&quot;@style/TextAppearance.Design.Snackbar.Message&quot; android:maxLines=&quot;2&quot; android:layout_gravity=&quot;center_vertical|left|start&quot; android:ellipsize=&quot;end&quot; android:textAlignment=&quot;viewStart&quot;/&gt;&lt;Button android:id=&quot;@+id/snackbar_action&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;0dp&quot; android:layout_marginStart=&quot;0dp&quot; android:layout_gravity=&quot;center_vertical|right|end&quot; android:paddingTop=&quot;14dp&quot; android:paddingBottom=&quot;14dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:visibility=&quot;gone&quot; android:textColor=&quot;?attr/colorAccent&quot; style=&quot;?attr/borderlessButtonStyle&quot;/&gt;&lt;/merge&gt; snackbar_text 是 Snackbar 左侧显示文字的 id ，找到这个 id 并设置颜色就 OK 了，如下所示 123456789101112131415161718snackbar = Snackbar.make(view,&quot;我是Snackbar&quot;,Snackbar.LENGTH_INDEFINITE) .setAction(&quot;按钮&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;);snackbar.show();snackbar.setActionTextColor(Color.WHITE);setSnackbarColor();//通过 getView() 方法获取 Snackbar 的父布局View view = snackbar.getView();if (view != null) &#123; //设置背景色 view.setBackgroundColor(getResources().getColor(R.color.colorAccent)); //获取 Snackbar 左侧提示信息的控件，修改字体颜色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(Color.WHITE);&#125; 显示效果如下： 4.3 在 Snackbar 中添加图标 实际上，添加图标，并不符合 Google 的设计规范和初衷，不建议添加图片这里只附上一篇添加图片的链接：http://www.jianshu.com/p/cd1e80e64311]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 FloatingActionButton]]></title>
      <url>%2F2017%2F04%2F25%2FAndroid%E4%B9%8BFloatingActionButton%2F</url>
      <content type="text"><![CDATA[一、简介 FloatingActionButton 是 Android 5.0 之后新出的一个控件，属于 com.android.support:design 包下，可以帮助我们轻松的实现悬浮按钮的效果。 我们看一下这个控件的继承关系，这家伙实际上是一个 ImageButton 二、简单使用2.1 要先在 app 的 build.gradle 中添加依赖12//个人认为与 V7 包的版本一致最好 compile &apos;com.android.support:design:25.3.1&apos; 2.2 xml 文件如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;FloatingActionButton&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/floating&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/floating_icon&quot; /&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 上边的代码中我们指定了 FloatingActionButton 的位置为： bottom|end ，边界为：16dp ，并且设置了要显示的图片 2.3 设置完 xml 文件之后直接运行，效果如下： 图片是自己找的，会发现默认的颜色就是粉色，即 styles.xml 中的颜色： 1&lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; 大小我也没有设置，默认大小就是这么大。 2.4 FloatingActionButton 在 xml 中的其他常用属性 修改背景色： app:backgroundTint=”@color/colorPrimaryDark” 修改按钮未按下时悬浮高度（阴影）：app:elevation=”10dp”，默认是6dp 设置按钮按下时的悬浮高度：app:pressedTranslationZ=”10dp” 默认是12dp 显示的图片：android:src=”@drawable/floating_icon” 修改显示大小：app:fabSize=”normal” normal和auto显示一样，mini，显示小 设置钮点击之后显示的颜色： app:rippleColor=”@color/colorAccent” 设置按钮边框宽度，有种立体的效果：app:borderWidth=”5dp” 2.5 FloatingActionButton 的隐藏与显示123//默认有动画效果floating.show(); 显示floating.hide(); 隐藏 2.6 FloatingActionButton 的点击事件 它的点击事件与 ImageView 设置点击事件的方式一样，这一点由继承关系可以看出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Fragment 与 Activity 通信]]></title>
      <url>%2F2017%2F04%2F24%2FFragment%E4%B8%8EActivity%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[前言 本来打算把 Fragment 的内容写完，结果写着写着发现这个篇幅已经够长了，所以就先写通信这一块了，其他的另起篇幅 正文一、 Fragment 与 Activity 通信 所有的 Fragment 都是依附于 Activity 存在的，而通信则是 Fragment 与 Activity 之间相互传递数据。 一个 Activity 可以替换多个 Fragment ，Activity 就是这多个 Fragment 的管理者，考虑到 Fragment 的复用性，尽量降低 Fragment 与 Fragment 之间的耦合，不要用一个 Fragment 来操作另一个 Fragment，使用 Activity 来操作 Fragment 1. Activity 向 Fragment 传递数据通过 bundle 在动态添加 Fragment 的过程中，我们在 Activity 中通过 Fragment.setArguments() 的方法为 Fragment 提供数据，setArguments 方法需要传递一个 Bundle，把需要传递的数据放在 Bundle 中即可 123Bundle bundle = new Bundle();bundle.putString(&quot;name&quot;,&quot;zhangsan&quot;);firstFragment.setArguments(bundle); 在 Fragment 中，在 onAttach() 函数中通过调用 getArguments() 获得一个 Bundle 对象，从而获取我们提供的数据。 12345 @Overridepublic void onAttach(Context context) &#123; super.onAttach(context); name = (String) getArguments().get(&quot;name&quot;);&#125; 2. 在Fragment中可以通过 getActivity 得到当前绑定的 Activity 的实例，然后进行操作。 假如 Fragment 依附的 Activity 中有这样一个方法： 1234public String getName()&#123; return &quot;lisi&quot;;&#125; 在 Fragment 中可以这样获取 12HuiTuiZhanActivity activity = (HuiTuiZhanActivity) getActivity();String name = activity.getName(); 3. 实现Fragment 中改变 Activity 中的控件内容通过设置回调接口来实现该效果 Fragment 中的代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.example.administrator.fragment_text.huituizhan;import android.content.Context;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import butterknife.Unbinder;/** * Created by Administrator on 2017/4/10. */public class FirstFragment extends Fragment &#123; @BindView(R.id.editText) EditText editText; @BindView(R.id.btn) Button btn; Unbinder unbinder; @BindView(R.id.bt2n) Button bt2n; private String name; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; Log.i(&quot;FirstFragment&quot;, &quot;onCreateView&quot;); View inflate = inflater.inflate(R.layout.huituizhan_first_fragment, container, false); unbinder = ButterKnife.bind(this, inflate); return inflate; &#125; /** * 点击第一个按钮切换到 SecondFragment *点击第二个按钮触发自定义接口中的方法，具体做什么就看宿主 Activity */ @OnClick(&#123;R.id.btn, R.id.bt2n&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.btn: FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); SecondFragment secondFragment = new SecondFragment(); fragmentTransaction.hide(this);// fragmentTransaction.remove(this); fragmentTransaction.add(R.id.framelayout, secondFragment, &quot;second&quot;); fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); break; case R.id.bt2n: //当需要切换 Activity 中的 TextView 的时候触发该接口中的方法 onBt2nClickListener.OnBt2nClick(); break; &#125; &#125; private OnBt2nClickListener onBt2nClickListener; public void setOnBt2nClickListener(OnBt2nClickListener onBt2nClickListener)&#123; this.onBt2nClickListener = onBt2nClickListener; &#125; /** * 自定义回调接口 */ public interface OnBt2nClickListener&#123; public void OnBt2nClick(); &#125;&#125; Activity 中的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.example.administrator.fragment_text.huituizhan;import android.os.Bundle;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.support.v7.app.AppCompatActivity;import android.widget.Button;import android.widget.FrameLayout;import android.widget.TextView;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;public class HuiTuiZhanActivity extends AppCompatActivity &#123; @BindView(R.id.framelayout) FrameLayout framelayout; @BindView(R.id.textView) TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hui_tui_zhan); ButterKnife.bind(this); FragmentManager supportFragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = supportFragmentManager.beginTransaction(); FirstFragment firstFragment = new FirstFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;name&quot;, &quot;zhangsan&quot;); firstFragment.setArguments(bundle); fragmentTransaction.add(R.id.framelayout, firstFragment, &quot;first&quot;).commit(); &#125; @Override protected void onResume() &#123; super.onResume(); FirstFragment first = (FirstFragment) getSupportFragmentManager().findFragmentByTag(&quot;first&quot;); first.setOnBt2nClickListener(new FirstFragment.OnBt2nClickListener() &#123; @Override public void OnBt2nClick() &#123; textView.setText(&quot;珞神&quot;); &#125; &#125;); &#125;&#125; 这样就实现了，在点击 Fragment 中的按钮的时候，改变 Activity 中的 TextView 显示的内容，并且降低 Fragment 与 Activity 的耦合性，并增强了 Fragment 的复用性，哪个 Activity 都能用这个 Fragment 4. 实现 Fragment 来操作另一个 FragmentFragment1 操作另一个 Fragment2,不应在Fragment1 中直接来操作，应该交给他们共同的宿主 Activity 来操作，也是通过设置接口来实现。 测试逻辑概述： FirstFragment 中的按钮切换 Activity 中的 TextView ，SecondFragment 中的按钮切换 ThreeFragment FirstFragment 中的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.example.administrator.fragment_text.huituizhan;import android.content.Context;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import butterknife.Unbinder;/** * Created by Administrator on 2017/4/10. */public class FirstFragment extends Fragment &#123; @BindView(R.id.editText) EditText editText; @BindView(R.id.btn) Button btn; Unbinder unbinder; @BindView(R.id.bt2n) Button bt2n; private String name; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; Log.i(&quot;FirstFragment&quot;, &quot;onCreateView&quot;); View inflate = inflater.inflate(R.layout.huituizhan_first_fragment, container, false); unbinder = ButterKnife.bind(this, inflate); editText.setText(name); return inflate; &#125; /** * 点击按钮切换到 SecondFragment */ @OnClick(&#123;R.id.btn, R.id.bt2n&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.btn: FragmentManager fragmentManager = getActivity().getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); SecondFragment secondFragment = new SecondFragment(); fragmentTransaction.hide(this); fragmentTransaction.add(R.id.framelayout, secondFragment, &quot;second&quot;); fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); break; case R.id.bt2n: //如果宿主 Activity 实现了此接口 if (getActivity() instanceof OnBt2nClickListener) &#123; //当需要切换 Activity 中的 TextView 的时候触发该接口中的方法 ((OnBt2nClickListener) getActivity()).OnBt2nClick(); &#125; break; &#125; &#125;// private OnBt2nClickListener onBt2nClickListener;////// public void setOnBt2nClickListener(OnBt2nClickListener onBt2nClickListener)&#123;// this.onBt2nClickListener = onBt2nClickListener;// &#125; /** * 自定义回调接口 */ public interface OnBt2nClickListener &#123; public void OnBt2nClick(); &#125;&#125; 注意： 这里的回调采用了另一种方式： 123456//如果宿主 Activity 实现了此接口if (getActivity() instanceof OnBt2nClickListener) &#123; //当需要切换 Activity 中的 TextView 的时候触发该接口中的方法 ((OnBt2nClickListener) getActivity()).OnBt2nClick(); &#125; SecondFragment 中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.example.administrator.fragment_text.huituizhan;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import butterknife.Unbinder;/** * Created by Administrator on 2017/4/10. */public class SecondFragment extends Fragment &#123; @BindView(R.id.editText) EditText editText; @BindView(R.id.btn) Button btn; Unbinder unbinder; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.huituizhan_second_fragment, container, false); unbinder = ButterKnife.bind(this, inflate); Log.i(&quot;SecondFragment&quot;, &quot;onCreateView&quot;); return inflate; &#125; @OnClick(R.id.btn) public void onViewClicked() &#123; if (getActivity() instanceof OnBt22222nClickListener) &#123; //当需要切换 Activity 中的 TextView 的时候触发该接口中的方法 ((OnBt22222nClickListener) getActivity()).OnBt22222nClick(); &#125; &#125; private OnBt22222nClickListener onBt22222nClickListener;--&gt; public void setOnBt22222nClickListener(OnBt22222nClickListener onBt22222nClickListener) &#123;--&gt; this.onBt22222nClickListener = onBt22222nClickListener;--&gt; &#125; /** * 自定义回调接口 */ public interface OnBt22222nClickListener &#123; public void OnBt22222nClick(); &#125;&#125; 注意： SecondFragment 中的回调设置与 FirstFragment 中的一样，我试过按照常规方式 ( setOnBt22222nClickListener 方式 ) 设置，切换 Fragment 的时候程序崩溃，而这种方式则没问题，不知道为嘛 - -！ Activity 中的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.example.administrator.fragment_text.huituizhan;import android.os.Bundle;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.support.v7.app.AppCompatActivity;import android.widget.Button;import android.widget.FrameLayout;import android.widget.TextView;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;public class HuiTuiZhanActivity extends AppCompatActivity implements FirstFragment.OnBt2nClickListener, SecondFragment.OnBt22222nClickListener &#123; @BindView(R.id.framelayout) FrameLayout framelayout; @BindView(R.id.textView) TextView textView; private SecondFragment second; private FirstFragment firstFragment; private ThreeFragment three; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hui_tui_zhan); ButterKnife.bind(this); FragmentManager supportFragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = supportFragmentManager.beginTransaction(); firstFragment = new FirstFragment(); Bundle bundle = new Bundle(); bundle.putString(&quot;name&quot;, &quot;zhangsan&quot;); firstFragment.setArguments(bundle); fragmentTransaction.add(R.id.framelayout, firstFragment, &quot;first&quot;).commit(); &#125; //FirstFragment 中回调的点击事件 @Override public void OnBt2nClick() &#123; textView.setText(&quot;珞神&quot;); if (second == null) &#123; second = new SecondFragment(); second.setOnBt22222nClickListener(this); &#125; &#125; //SecondFragment 中回调的点击事件 @Override public void OnBt22222nClick() &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); if (three == null) &#123; three = new ThreeFragment(); &#125; if (second == null) &#123; second = new SecondFragment(); &#125;// fragmentTransaction.hide(second);// fragmentTransaction.add(R.id.framelayout,three,&quot;three&quot;); fragmentTransaction.replace(R.id.framelayout, three, &quot;three&quot;); fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); &#125;&#125; 5. 通过 getFragmentManager.findFragmentByTag() 或者 findFragmentById() 获得任何 Fragment 实例，然后来操作 Fragment 中的方法。 假如 Fragment 中有这样一个方法： 1234public String getName()&#123; return &quot;珞神&quot;;&#125; 在其宿主 Activity 中可以这样操作： 12FirstFragment first = (FirstFragment) getSupportFragmentManager().findFragmentByTag(&quot;first&quot;);String name = first.getName(); 至此，完结！如有错误和遗漏，一经发现，必然改正！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 Fragment 生命周期、常用 API、回退栈]]></title>
      <url>%2F2017%2F04%2F22%2FAndroid%E4%B9%8BFragment%2F</url>
      <content type="text"><![CDATA[前言 本篇介绍 Fragment 的生命周期、常用 API 、简单使用、回退栈 参考博客：http://blog.csdn.net/lmj623565791/article/details/37970961 参考博客：http://blog.csdn.net/lmj623565791/article/details/37992017 正文一、Fragment 的由来Fragment 是在 Android 3.0 之后引入的，主要是为了解决手机和屏幕的适配问题，同时，也能相应解决 activity 中代码量过大的问题，不过，从 Fragment 问世以来，相关的争论就不断，有同意使用的，也有反对使用的，反对的大部分原因就是坑太多，不好用，但是就我来看，用的人还是很多，而且本人也在经常使用，所以就来篇 Fragment 的大总结。 二、Fragment 的生命周期Fragment 是嵌套在 Activity 中使用的，生命周期也与 Activity 极其相似，除了与 Activity 相同的几个生命周期方法之外，另加了几个与 Activity 相交互的几个方法，如下图所示： 几个额外的方法的介绍如下： onAttach(Context context) ：当 Fragment 与 Activity 发生关联的时候调用，（ Activity 传递到此方法内） 此方法内部还是调用的 onAttach(Activity activity) 方法 onCreateView ( LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState ) 创建 Fragment 视图的时候调用， onViewCreated(View view, @Nullable Bundle savedInstanceState) 在 Activity 的 onCreate() 方法已返回时调用。 onDestroyView() 与 onCreateView 对应，当该 Fragment 的视图被移除时调用 onDetach() 与 onAttach 相对应，当 Fragment 与 Activity 关联被取消时调用 三、不同包下的 Fragment 的区别Fragment 分两个不同包下： android.support.v4.app.Fragment； android.app.Fragment； 区别如下： 兼容版本不同 v4 包下的是为了兼容之 1.6 系统。 另一个包下的是兼容 3.0 以上系统。不过这个现在没啥用了，因为现在的手机基本都在 4.0 以上了 大家都知道 Fragment 是嵌套在 Activity 中使用的，对 Activity 的要求不同 v4 包下的就要求这个 Activity 必须继承自FragmentActivity 另一个包下的不要求，其中 FragmentActivity 集成自 Activity 获取 FragmentManager 的方式不同 v4 包下的是通过：getSupportFragmentManager(); 另一个包下的是：getFragmentManager(); 注意： 关于 Fragment 的一切都要配套使用，注意导包问题否则容易出现类似这种错误： wrong 2nd argument type found ‘android.app.Fragment.’ required ‘Android.support.v4.app.Fragment’ 四、Fragment 常用 API FragmentManager 这是 Fragment 管理者，要想操作 Fragment 必须先获取管理者，根据不同的包，有两种获取方式：getFragmentManager() // v4 中，getSupportFragmentManager FragmentTransaction 所有的操作都是基于此类的，调用此类的一系列方法来管理 Fragment ， 获取方式：fragmentManager.beginTransaction()；方法大致如下： add() 往Activity中添加一个Fragment remove() 从 Activity 中移除一个 Fragment，如果被移除的 Fragment 没有添加到回退栈这个 Fragment 实例将会被销毁。 replace() 使用另一个 Fragment 替换当前的，实际上就是 remove() 和 add() 的合体 hide() 隐藏当前的 Fragment，仅仅是设为不可见，并不会销毁 show() 显示之前隐藏的 Fragment detach() 会将 view 从 UI 中移除,和 remove() 不同,此时 fragment 的状态依然由 FragmentManager 维护。 attach() 重建 view 视图，附加到 UI 上并显示。 commit() 提交一个事务，此方法必须要在 Activity 的 onSaveInstanceState 方法之前调用 五、使用 Fragment 的最简单的操作1. 两个 Fragment123456789public class FirstFragment extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.firstfragment_layout, container, false); return inflate; &#125; 12345678public class SecondFragment extends Fragment &#123; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.secondfragment_layout, container, false); return inflate; &#125; 2. Activity 中123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.btn) Button btn; @BindView(R.id.fragment) FrameLayout fragment; private FragmentManager fragmentManager; private FirstFragment firstFragment; private FragmentTransaction fragmentTransaction; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); setDefaultFragment(); &#125; /** * 设置默认的 fragment */ private void setDefaultFragment() &#123; fragmentManager = getSupportFragmentManager(); fragmentTransaction = fragmentManager.beginTransaction(); firstFragment = new FirstFragment(); fragmentTransaction.add(R.id.fragment, firstFragment, &quot;first&quot;).commit(); &#125; @OnClick(R.id.btn) public void onViewClicked() &#123; FragmentManager supportFragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction1 = supportFragmentManager.beginTransaction(); SecondFragment secondFragment = new SecondFragment(); fragmentTransaction1.replace(R.id.fragment, secondFragment, &quot;second&quot;); fragmentTransaction1.commit(); &#125;&#125; 3. activity 中的 xml 文件如下：12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.example.administrator.fragment_text.MainActivity&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/fragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 点击按钮之后就能切换 Fragment 六、 Fragment 回退栈 ( 包含 Fragment 常用 API 调用生命周期方法详解 ) 个人对回退栈的理解为： 当 Fragment 入栈之后，能够保存此 Fragment 的状态，通过返回键再次回到此 Fragment 的时候，数据依然存在！ 回退栈就像 Activity 一样，先进后出，一层一层的 由于是真机测试，所以没法提供动图 测试逻辑大概是这样的：三个 Fragment 按顺序跳转，每个 Fragment 中都有一个输入框，测试是否能保存输入框中的内容，及调用的生命周期方法。 1. 三个 Fragment 分别为： FirstFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.example.administrator.fragment_text.huituizhan;import android.content.Context;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import butterknife.Unbinder;/** * Created by Administrator on 2017/4/10. */public class FirstFragment extends Fragment &#123; @BindView(R.id.editText) EditText editText; @BindView(R.id.btn) Button btn; Unbinder unbinder; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; Log.i(&quot;FirstFragment&quot;,&quot;onCreateView&quot;); View inflate = inflater.inflate(R.layout.huituizhan_first_fragment, container, false); unbinder = ButterKnife.bind(this, inflate); return inflate; &#125; @Override public void onAttach(Context context) &#123; Log.i(&quot;FirstFragment&quot;,&quot;onAttach&quot;); super.onAttach(context); &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; Log.i(&quot;FirstFragment&quot;,&quot;onCreate&quot;); super.onCreate(savedInstanceState); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; Log.i(&quot;FirstFragment&quot;,&quot;onViewCreated&quot;); super.onViewCreated(view, savedInstanceState); &#125; @Override public void onStart() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onStart&quot;); super.onStart(); &#125; @Override public void onResume() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onResume&quot;); super.onResume(); &#125; @Override public void onPause() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onPause&quot;); super.onPause(); &#125; @Override public void onStop() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onStop&quot;); super.onStop(); &#125; @Override public void onDestroyView() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onDestroyView&quot;); super.onDestroyView(); unbinder.unbind(); &#125; @Override public void onDestroy() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onDestroy&quot;); super.onDestroy(); &#125; @Override public void onDetach() &#123; Log.i(&quot;FirstFragment&quot;,&quot;onDetach&quot;); super.onDetach(); &#125; /** * 点击按钮切换到 SecondFragment */ @OnClick(R.id.btn) public void onViewClicked() &#123; FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); SecondFragment secondFragment = new SecondFragment(); fragmentTransaction.hide(this); fragmentTransaction.add(R.id.framelayout,secondFragment,&quot;second&quot;); // 将 FirstFragment 添加至 回退栈 fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); &#125;&#125; 注意此处切换 Fragment 使用的是： 12fragmentTransaction.hide(this);fragmentTransaction.add(R.id.framelayout,secondFragment,&quot;second&quot;); SecondFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.example.administrator.fragment_text.huituizhan;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import butterknife.Unbinder;/** * Created by Administrator on 2017/4/10. */public class SecondFragment extends Fragment &#123; @BindView(R.id.editText) EditText editText; @BindView(R.id.btn) Button btn; Unbinder unbinder; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.huituizhan_second_fragment, container, false); unbinder = ButterKnife.bind(this, inflate); Log.i(&quot;SecondFragment&quot;,&quot;onCreateView&quot;); return inflate; &#125; @Override public void onAttach(Context context) &#123; Log.i(&quot;SecondFragment&quot;,&quot;onAttach&quot;); super.onAttach(context); &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; Log.i(&quot;SecondFragment&quot;,&quot;onCreate&quot;); super.onCreate(savedInstanceState); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; Log.i(&quot;SecondFragment&quot;,&quot;onViewCreated&quot;); super.onViewCreated(view, savedInstanceState); &#125; @Override public void onStart() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onStart&quot;); super.onStart(); &#125; @Override public void onResume() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onResume&quot;); super.onResume(); &#125; @Override public void onPause() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onPause&quot;); super.onPause(); &#125; @Override public void onStop() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onStop&quot;); super.onStop(); &#125; @Override public void onDestroyView() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onDestroyView&quot;); super.onDestroyView(); unbinder.unbind(); &#125; @Override public void onDestroy() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onDestroy&quot;); super.onDestroy(); &#125; @Override public void onDetach() &#123; Log.i(&quot;SecondFragment&quot;,&quot;onDetach&quot;); super.onDetach(); &#125; @OnClick(R.id.btn) public void onViewClicked() &#123; FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); ThreeFragment threeFragment = new ThreeFragment(); fragmentTransaction.replace(R.id.framelayout,threeFragment,&quot;three&quot;); fragmentTransaction.addToBackStack(null); fragmentTransaction.commit(); &#125;&#125; 注意此处切换 Fragment 使用的是： 1fragmentTransaction.replace(R.id.framelayout,threeFragment,&quot;three&quot;); ThreeFragment 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.example.administrator.fragment_text.huituizhan;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;import butterknife.OnClick;import butterknife.Unbinder;/** * Created by Administrator on 2017/4/10. */public class ThreeFragment extends Fragment &#123; @BindView(R.id.editText) EditText editText; @BindView(R.id.btn) Button btn; Unbinder unbinder; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; View inflate = inflater.inflate(R.layout.huituizhan_three_fragment, container, false); unbinder = ButterKnife.bind(this, inflate); return inflate; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind(); &#125; @OnClick(&#123;R.id.editText, R.id.btn&#125;) public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.editText: break; case R.id.btn: Toast.makeText(getActivity().getApplicationContext(),&quot;最后一个了&quot;,Toast.LENGTH_SHORT) .show(); break; &#125; &#125;&#125; 2. Activity 中的代码为：123456789101112131415161718192021222324252627282930313233package com.example.administrator.fragment_text.huituizhan;import android.os.Bundle;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.support.v7.app.AppCompatActivity;import android.widget.FrameLayout;import com.example.administrator.fragment_text.R;import butterknife.BindView;import butterknife.ButterKnife;public class HuiTuiZhanActivity extends AppCompatActivity &#123; @BindView(R.id.framelayout) FrameLayout framelayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_hui_tui_zhan); ButterKnife.bind(this); FragmentManager supportFragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = supportFragmentManager.beginTransaction(); FirstFragment firstFragment = new FirstFragment(); fragmentTransaction.add(R.id.framelayout,firstFragment,&quot;first&quot;).commit(); &#125;&#125; 3. 运行之后，hide、add 与 replace 都能保存数据，但是生命周期不太一样，如下所示： FirstFragment 跳转到 SecondFragment 时： 12345678910111204-22 13:43:10.160 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onAttach04-22 13:43:10.160 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onCreate04-22 13:43:10.160 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onCreateView04-22 13:43:10.180 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onViewCreated04-22 13:43:10.180 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onStart04-22 13:43:10.180 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onResume04-22 13:43:26.605 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onAttach04-22 13:43:26.605 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onCreate04-22 13:43:26.615 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onCreateView04-22 13:43:26.620 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onViewCreated04-22 13:43:26.620 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onStart04-22 13:43:26.620 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onResume 注意： 此处切换的时候，没有立马调用 FirstFragment 的 onPause、onStop、onDestroyView SecondFragment 跳转到 ThreeFragment 时： 12345604-22 13:45:22.035 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onPause04-22 13:45:22.035 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onStop04-22 13:45:22.035 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onDestroyView04-22 13:45:22.040 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onPause04-22 13:45:22.040 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onStop04-22 13:45:22.040 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onDestroyView 注意：此处是先调用 SecondFragment 的 onPause、onStop、onDestroyView，然后才调用 FirstFragment 的对应方法， 按返回键 ThreeFragment 回退到 SecondFragment 时： 1234567804-22 13:51:26.075 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onCreateView04-22 13:51:26.085 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onViewCreated04-22 13:51:26.090 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onStart04-22 13:51:26.090 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onResume04-22 13:51:26.095 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onCreateView04-22 13:51:26.100 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onViewCreated04-22 13:51:26.100 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onStart04-22 13:51:26.100 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onResume 注意： 此处竟然先调用的是 FirstFragment 的 onCreateView、onViewCreated、onStart、onResume 继续按返回键 SecondFragment 回退到 FirstFragment 时： 1234504-22 13:52:30.825 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onPause04-22 13:52:30.825 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onStop04-22 13:52:30.825 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onDestroyView04-22 13:52:30.825 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onDestroy04-22 13:52:30.825 15361-15361/com.example.administrator.fragment_text I/SecondFragment: onDetach 继续返回键 退出 Activity 时： 1234504-22 13:53:33.675 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onPause04-22 13:53:34.045 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onStop04-22 13:53:34.045 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onDestroyView04-22 13:53:34.045 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onDestroy04-22 13:53:34.045 15361-15361/com.example.administrator.fragment_text I/FirstFragment: onDetach 4. Fragment 退栈方式这有个哥们写的非常详细：http://blog.csdn.net/u010049692/article/details/38944867]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 DrawerLayout 详解]]></title>
      <url>%2F2017%2F04%2F22%2FAndroid%E4%B9%8BDrawerLayout%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[前言本篇文章，参考 《第一行代码第2版》 正文1. 简介DrawerLayout 是谷歌推荐的一种实现侧滑菜单的控件，是 Material Design 中非常常见的效果。 2. 简单用法2.1 创建项目之后，我们修改 xml 布局如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:paddingTop=&quot;25dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;自定义标题&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/FrameLayout&gt; &lt;!-- android:layout_gravity=&quot;start&quot; 属性必须指定，left 菜单在左侧，right 菜单在右侧，start 表示跟随系统--&gt; &lt;TextView android:id=&quot;@+id/textview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:background=&quot;#fff&quot; android:gravity=&quot;center&quot; android:paddingTop=&quot;50dp&quot; android:text=&quot;我是菜单栏&quot; android:textSize=&quot;30dp&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 最外层是 android.support.v4.widget 包下的 DrawerLayout 接下来是两个子 View ，一个为 FrameLayout ,另一个为 TextView FrameLayout 中是一个 Toolbar ，注意，FrameLayout 这一层视图不能省，否则 Toolbar 会撑满整个屏幕，就算设置 Toolbar 的高度为固定值也不行。 DrawerLayout 的直接子 View 中的 TextView 就是我们要显示的菜单，当然也可以是其他的布局，因为 DrawerLayout 是继承自 ViewGroup 的，我只是图省事，写了个 Textview， 2.2 Activity 中的代码如下：12345678910111213141516171819202122232425262728293031323334package io.github.adsuper.drawerlayouttext;import android.os.Build;import android.os.Bundle;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.MenuItem;import android.view.WindowManager;public class MainActivity extends AppCompatActivity &#123; DrawerLayout drawerlayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setNavigationIcon(R.drawable.setting); toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar);&#125; 注意： Activity 中的代码全都是设置状态栏和 Toolbar 的，与 DrawerLayout 无关，这里贴出来，只是为了美化 Toolbar 而已！ 对 Toolbar 不太了解的可以参考我这篇博客：Android 之 Toolbar 汇总 2.3 运行之后 ( API 19 手机 ) ，效果图如下所示： 菜单栏打开前： 菜单栏打开后： 2.4 优化启动方式 这个菜单栏的启动方式只有一种，只有在贴近屏幕边缘的地方滑动才会出现，为了防止有些用户压根就不知道菜单栏的这种情况，我们增加一种启动方式 看到标题栏左上角的那个导航图标了吧，我们就是要把这个图标和菜单栏联动起来 布局文件不用改变，修改 Activity 中的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package io.github.adsuper.drawerlayouttext;import android.os.Build;import android.os.Bundle;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.MenuItem;import android.view.WindowManager;public class MainActivity extends AppCompatActivity &#123; DrawerLayout drawerlayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); //查找 drawerlayout 控件 drawerlayout = (DrawerLayout) findViewById(R.id.drawerlayout); toolbar.setNavigationIcon(R.drawable.setting); toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar); &#125; //重写 onOptionsItemSelected 方法 @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; //这个 id 就是标题栏左侧的导航图标的 id 是固定的！ case android.R.id.home: //使用 openDrawer 打开菜单栏 drawerlayout.openDrawer(GravityCompat.START); break; &#125; return true; &#125;&#125; 注意： 查找 drawerlayout 控件时，本人使用了 ButterKnife 8.5.1 版本，却无法把效果显示出来。 打开或关闭 DrawerLayout ，执行以下代码： 1234//关闭drawerLayout.closeDrawer(GravityCompat.START);//打开drawerLayout.openDrawer(GravityCompat.START); 2.5 修改 DrawerLayout 位置 接下来说的是修改 DrawerLayout 上边距的位置，将其放在 Toolbar 的下方 只需要修改布局，改变 DrawerLayout 的布局位置即可，xml 代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:paddingTop=&quot;25dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;自定义标题&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v4.widget.DrawerLayout android:id=&quot;@+id/drawerlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!-- android:layout_gravity=&quot;start&quot; 属性必须指定，left 菜单在左侧，right 菜单在右侧，start 表示跟随系统--&gt; &lt;TextView android:id=&quot;@+id/textview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:background=&quot;#e98484&quot; android:gravity=&quot;center&quot; android:paddingTop=&quot;50dp&quot; android:text=&quot;我是菜单栏&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/LinearLayout&gt; 运行效果如下所示： 3. DrawerLayout 配合 NavigatianView 使用实际上 DrawerLayout 可以内置任何布局来完善你的侧滑菜单，但是谷歌推荐使用 NavigationView ， NavigationView 是 Design Support 库中提供的一个控件，此控件会简化侧滑菜单页面的实现，下边开始使用： 3.1 添加 Design Support 依赖包12// 个人认为，包的版本与 V7 包一致compile &apos;com.android.support:design:25.3.1&apos; 3.2 xml 布局中，将原来的 TextView 替换为 NavigationView，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:fitsSystemWindows=&quot;true&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;自定义标题&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/FrameLayout&gt; &lt;!-- android:layout_gravity=&quot;start&quot; 属性必须指定，left 菜单在左侧，right 菜单在右侧，start 表示跟随系统--&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/navigationview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/navigation_head_layout&quot; app:menu=&quot;@menu/navigation_menu&quot;&gt;&lt;/android.support.design.widget.NavigationView&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 效果如下所示：注意 NavigationView 中的两条属性 12app:headerLayout=&quot;@layout/navigation_head_layout&quot;app:menu=&quot;@menu/navigation_menu&quot; app:headerLayout 为头布局，即粉色背景部分，navigation_head_layout 的布局如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--180dp 是 NavigationView 比较适合的高度--&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; android:padding=&quot;10dp&quot; android:background=&quot;@color/colorAccent&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/circle_me&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;60dp&quot; android:layout_centerInParent=&quot;true&quot; android:src=&quot;@drawable/navigation_me&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/textview1&quot; android:layout_alignParentBottom=&quot;true&quot; android:text=&quot;个人博客：https://adsuper.github.io&quot; android:textSize=&quot;16dp&quot; android:textColor=&quot;#fff&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/textview2&quot; android:layout_above=&quot;@id/textview1&quot; android:text=&quot;珞璃之神&quot; android:textSize=&quot;16dp&quot; android:textColor=&quot;#fff&quot; /&gt;&lt;/RelativeLayout&gt; 其中，CircleImageView 是一个第三方的，专门将图片设置为圆形的框架，需要添加依赖： 1compile &apos;de.hdodenhof:circleimageview:2.1.0&apos; app:menu 为下方具体的菜单选项，navigation_menu 布局如下：(需要在 menu 文件夹下创建) 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;!-- group 标签中的 android:checkableBehavior=&quot;single 设置为单选--&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/mingjiao&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;明教&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/tianshan&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;天山&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/gaibang&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;丐帮&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/murong&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;慕容&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/xiaoyao&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;逍遥&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/tianlong&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;天龙&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/wudang&quot; android:icon=&quot;@drawable/navigation_icon&quot; android:title=&quot;武当&quot;&gt;&lt;/item&gt; &lt;/group&gt;&lt;/menu&gt; 3.3 activity 中的代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package io.github.adsuper.drawerlayouttext;import android.os.Build;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.design.widget.NavigationView;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBar;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.MenuItem;import android.view.WindowManager;import butterknife.BindView;import butterknife.ButterKnife;public class MainActivity extends AppCompatActivity &#123; DrawerLayout drawerlayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main4_2); //设置透明状态栏 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); drawerlayout = (DrawerLayout) findViewById(R.id.drawerlayout); NavigationView navigationView = (NavigationView) findViewById(R.id.navigationview); toolbar.setNavigationIcon(R.drawable.setting); toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar); navigationView.setCheckedItem(R.id.mingjiao);//设置默认选择的 item //设置 item 的点击事件 navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123;// drawerlayout.closeDrawer(GravityCompat.START); return true; &#125; &#125;); &#125; /** * 重写 onOptionsItemSelected 方法，实现标题栏左侧导航按钮打开侧滑菜单 * @param item * @return */ @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case android.R.id.home: drawerlayout.openDrawer(GravityCompat.START); break; &#125; return true; &#125;&#125; 3.4 当然也可以改变侧滑菜单的位置，也就是上边距的位置，放在 Toolbar 下,只需要修改布局即可：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:fitsSystemWindows=&quot;true&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:text=&quot;自定义标题&quot; android:textSize=&quot;20dp&quot; android:textStyle=&quot;bold&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;android.support.v4.widget.DrawerLayout android:id=&quot;@+id/drawerlayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/navigationview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/navigation_head_layout&quot; app:menu=&quot;@menu/navigation_menu&quot; /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/LinearLayout&gt; 显示效果如下： 至此，完结 如果想看详细的 Toolbar，请点击：Material Design 之 Toolbar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 Toolbar 汇总]]></title>
      <url>%2F2017%2F04%2F20%2FAndroid%E4%B9%8BToolbar%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[前言本篇文章，尽可能地总结 Toolbar 的知识点和用法，肯定没有概括完，会不断地查漏补缺。 正文一、概述 Toolbar 是 Android 5.0 之后被谷歌放出来的，是为了替代之前的 ActionBar ， Toolbar 不仅继承了 ActionBar 的所有功能，而且灵活性很高，可以配合其他控件来实现一些 Material Design 效果。 二、使用1. 新建一个项目，看 styles.xml123456&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 系统默认使用主题 ： Theme.AppCompat.Light.DarkActionBar 我们之前所有的项目中 自带的 ActionBar 就是因为指定了这个主题才出现的。 2. 修改主题1.首先要指定一个不带 ActionBar 的主题： Theme.AppCompat.Light.NoActionBar 背景为浅色的主题 Theme.AppCompat.NoActionBar 背景为深色的主题 本人喜欢浅色主题，如下所示： 123456&lt;style name=&quot;AppTheme2&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 2. 主题中各个属性的含义： colorPrimary 标题栏的颜色 colorPrimaryDark 状态栏的颜色 colorAccent 指定一个按钮的颜色，某些控件的选中状态也会选择这个颜色 3. 代码中简单使用1. 在主 Activity 的布局文件中修改如下：12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; &gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/FrameLayout&gt; 2. Acticity 中的代码如下：12345678910111213141516171819202122package io.github.adsuper.meterialtext;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import butterknife.BindView;import butterknife.ButterKnife;public class MainActivity extends AppCompatActivity &#123; Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); &#125;&#125; 这里必须使用 findViewById ，我试过 ButterKnife ，效果显示不出来 3. 实现效果与 ActionBar 一样，但是这是 toolbar4. 添加标题、子标题、右侧 menu 、左侧导航栏图标、logo1. 添加标题、子标题、、左侧导航栏图标、logo 在 Activity 中进行设置，如下所示： 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setTitle(&quot;title&quot;);//设置标题 toolbar.setSubtitle(&quot;suntitle&quot;);//设置子标题 toolbar.setLogo(R.mipmap.ic_launcher);//设置logo setSupportActionBar(toolbar); //设置导航栏图标要在 setSupportActionBar 之后 toolbar.setNavigationIcon(R.drawable.back6); &#125; 还可以通过 setTitleTextColor 、 setTitleTextAppearance 、 setSubtitleTextColor 、 setSubtitleTextAppearance 来设置不同的颜色 还可以通过在 xml 文件中设置，如下所示： 12345678//注意命名空间 &lt;android.support.v7.widget.Toolbar ... app:logo=&quot;@mipmap/ic_launcher&quot; app:title=&quot;Title&quot; app:subtitle=&quot;Sub Title&quot; app:titleTextColor=&quot;#ffffff&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; 2. 设置右侧 menu 菜单 第一步：右键点击 res 文件夹，创建 Menu resource file ，命名为 toolbar.xml，内容如下所示： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/set1&quot; android:icon=&quot;@drawable/setting&quot; android:title=&quot;11111&quot; app:showAsAction=&quot;always&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/set2&quot; android:icon=&quot;@drawable/setting&quot; android:title=&quot;22222&quot; app:showAsAction=&quot;ifRoom&quot;&gt;&lt;/item&gt; &lt;item android:id=&quot;@+id/set3&quot; android:icon=&quot;@drawable/setting&quot; android:title=&quot;33333&quot; app:showAsAction=&quot;never&quot;&gt;&lt;/item&gt;&lt;/menu&gt; 其中，always 表示总是显示在标题栏，ifRoom 表示控件足够的话显示在标题栏 ，never 表示不显示在标题栏 第二步：重写 Activity 中的 onCreateOptionsMenu 方法，填充布局： 123456@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true;&#125; 第三步：重写 Activity 中的 onOptionsItemSelected 方法，响应 menu 菜单的点击事件 123456789101112131415161718192021@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.set1: Toast.makeText(getApplicationContext(),&quot;set1&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.set2: Toast.makeText(getApplicationContext(),&quot;set2&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.set3: Toast.makeText(getApplicationContext(),&quot;set3&quot;,Toast.LENGTH_SHORT).show(); break; case android.R.id.home: Toast.makeText(getApplicationContext(),&quot;左侧导航栏图标&quot;,Toast.LENGTH_SHORT).show(); break; &#125; return true;&#125; 其中：android.R.id.home 是左侧导航栏图标的 id 第四步：运行结果如下： 由于第三个图标设置的是 never 所以没有显示出来 ，点击最右侧的如表之后，显示如下： 其中，显示 33333 是因为 item 中的这条属性：android:title=”33333” 三、扩展1. 最后边的按钮点击之后显示出来的 item ，将其放在 toolbar 下方在 styles.xml 中添加以下代码： 1234567891011121314&lt;!--无标题栏***浅色背景主题--&gt; &lt;style name=&quot;AppTheme2&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;!--修改 popup menu 的位置，使其位于 Toolbar 的下方--&gt; &lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/MenuStyle&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;MenuStyle&quot; parent=&quot;Widget.AppCompat.Light.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;!--把该属性改为fals--&gt; &lt;/style&gt; 其中，AppTheme2 是我们自己用的主题，添加的代码看注释即可 运行效果如下所示： 2. 标题居中样式： 由于 Toolbar 继承于 ViewGroup ，所以可以在其内部放入一个 TextView 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:textStyle=&quot;bold&quot; android:text=&quot;自定义标题&quot; android:textSize=&quot;30dp&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/RelativeLayout&gt; 在 Activity 中设置 toolbar.setTitle(“”); 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar); toolbar.setNavigationIcon(R.drawable.back6); &#125; 效果如下： 3. 左侧显示 menu 菜单左侧显示 menu 主要是使用 android.support.v7.widget.ActionMenuView 第一步：布局文件设置如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--android:paddingTop=&quot;25dp&quot; 是状态栏的高度，--&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:minHeight=&quot;?attr/actionBarSize&quot; android:paddingTop=&quot;25dp&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;&gt; &lt;!--加入 ActionMenuView--&gt; &lt;android.support.v7.widget.ActionMenuView android:id=&quot;@+id/action_menu_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;!--自定义控件--&gt; &lt;TextView android:id=&quot;@+id/toolbar_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center&quot; android:gravity=&quot;center&quot; android:textStyle=&quot;bold&quot; android:text=&quot;自定义标题&quot; android:textSize=&quot;20dp&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/RelativeLayout&gt; 第二步：在 menu 菜单中 创建一个文件用于填充左侧 menu ，命名为：toolbar_left_menu.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/left_text_btn&quot; android:title=&quot;&quot; app:actionLayout=&quot;@layout/menu_left_text&quot; app:showAsAction=&quot;always&quot;/&gt;&lt;/menu&gt; 其中，app:actionLayout 属性表示新建一个 style 布局，填充这个 item ，主要作用是设置这个 item 的个性， @layout/menu_left_text 如下所示： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textview&quot; android:text=&quot;关闭&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20dp&quot; android:textColor=&quot;@color/colorAccent&quot; /&gt;&lt;/RelativeLayout&gt; 第三步，Activity 中的操作： 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); toolbar = (Toolbar) findViewById(R.id.toolbar); ActionMenuView actionMenuView = (ActionMenuView) toolbar.findViewById(R.id.action_menu_view); //填充 menu 布局 getMenuInflater().inflate(R.menu.toolbar_left_menu, actionMenuView.getMenu()); //设置 item 的点击事件(没有填充布局的 item ) actionMenuView.setOnMenuItemClickListener(new ActionMenuView.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123;// Toast.makeText(getApplicationContext(),&quot;关闭&quot;,Toast.LENGTH_SHORT).show(); return true; &#125; &#125;); // 找到 id 找到对应的 item MenuItem menuItem = actionMenuView.getMenu().findItem(R.id.left_text_btn); //设置 对应 item 填充布局的点击事件 menuItem.getActionView().setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getApplicationContext(),&quot;关闭&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); toolbar.setTitle(&quot;&quot;); setSupportActionBar(toolbar); &#125; 运行效果如下所示： 点击关闭按钮会响应对应的 toast 4. Toolbar 之状态栏适配方案详情参考：帅比张 Android 5.0 之前的版本，状态栏是黑色的，之后的状态栏是半透明的 1. 在使用的主题文件下添加如下代码：(要求 API 大于等于 19)12&lt;!--设置状态栏为透明的--&gt;&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 或者在 activity 中添加如下代码 12345//设置透明状态栏if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes();localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; 但是在代码里声明更有效！ 2. 在 Toolbar 中添加这么一条属性123456//因为状态栏的高度是 25dpandroid:paddingTop=&quot;25dp&quot;// 但是在 Toolbar 配合 Drawerlayout 嵌套 NavigationView 使用的时候，会出现问题，改为 android:fitsSystemWindows=&quot;true&quot; 在 API 19 上显示为： 在 API 21 上显示为：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 事件分发机制解析]]></title>
      <url>%2F2017%2F04%2F19%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[前言 事件分发机制是 Android 中的重点和难点，也是解决滑动冲突的理论基础。 本文参考书： 《Android 开发艺术探索》 参考的大神：http://www.gcssloop.com/customview/dispatch-touchevent-theory 正文1. 事件分发机制实际上是 MotionEvent ( 点击事件 ) 的传递规则。2. 事件分发机制涉及的三个方法 3. View 事件的传递流程 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，那么它的 onTouchEvent 方法就会被调用 View 的 onTouchEvent 方法默认都会消耗事件(返回 true)，除非是不可点击的( clickable 和 longClickable 同时为 false)，View 的 longClickable 属性默认都为 false ，而 clickable 属性分情况，比如 Button 默认为 true ，TextView 默认为 false View 的 enable 属性不影响 onTouchEvent 方法的返回值，哪怕是 disable 状态，只要 clickable 或者 longClickable 有一个为 true ，那么它的 onTouchEvent 就返回 true。 4. ViewGroup 事件的传递流程 5. 一些注意事项1. 所谓的点击事件，是指从 down 事件开始，中间可能含有数量不定的 move 事件，最终以 up 事件结束的一系列事件，称为：同一个事件序列2. 某个 View 一旦决定拦截事件，那么这一个事件序列都有它来处理。3. 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件( onTouchEvent )，那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交给它的父元素去处理，即父元素的 onTouchEvent 会被调用。4. 事件的传递过程都是由外向内的。5. onClick 发生的前提是当前 View 是可点击的，并且收到了 down 和 up 事件。6. actvity 对点击事件的分发过程1. 当一个点击操作发生时，事件最先传递给 Activity ，由 Activity 的 dispatchTouchEvent 来进行事件的分发，具体工作是由 Activity 内部的 Window 来完成的，Window 会将事件传递给 DecorView ，然后将事件传递给 Activity 的顶级 View ，也就是设置的 setContentView() ；12345678910// Activity 的 源码 dispatchTouchEvent 方法 public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 2.Window 是个抽象类，其 superDispatchTouchEvent 方法也是抽象方法，1234567// Window 类源码public abstract class Window &#123; /** Flag for the &quot;options panel&quot; feature. This is enabled by default. */ public static final int FEATURE_OPTIONS_PANEL = 0; /** Flag for the &quot;no title&quot; feature, turning off the title at the top * of the screen. */ public static final int FEATURE_NO_TITLE = 1; 在 Activity 源码中有这样一行代码： 1mWindow = new PhoneWindow(this, window) 从而可以知道 Window 类的实现类为 PhoneWindow ，而实际上 PhoneWindow 是其唯一的一个实现类 Android SDK 隐藏了 PhoneWindow 类源码，本人只好从网上找了源码，看 superDispatchTouchEvent 方法 123456public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; @Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 从这里可以看出 PhoneWindow 将事件传递给了 mDecor，也就是 DecorView ，其类如下： 1private final class DecorView extends FrameLayout &#123; 实际上 DecorView 是一个 FrameLayout ，而我们通过 setContentView 设置的 View 就是其一个子类。 然后，DecorView 就会将事件传递给 Activity 设置的 View，也就是顶级 View 接下来就是 View 对点击事件的分发过程了。 7. View 对点击事件的分发过程之前的 第 2 条、第 3 条和第 4 条 都讲过了，下边再叙述几点： 点击事件到达顶级 View 以后 (一般是一个 ViewGroup ) 如果顶级 ViewGroup 拦截事件的情况下，设置了 OnTouchListener ，则 onTouch 会被调用，反之会调用 onTouchEvent ，也就是说，如果都提供的话，onTouch 会屏蔽掉 onTouchEvent 。OnTouchListener 的优先级高于 onTouchEvent]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 自定义 View 实现原理]]></title>
      <url>%2F2017%2F04%2F18%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
      <content type="text"><![CDATA[前言 参考一位大神的 自定义 View 系列文章，其中一篇的链接为：http://www.gcssloop.com/customview/CoordinateSystem 文章的内容基本是链接的形式，因为大神写的很详细，本人是抱着学习的心态来总结的 内容涉及的是自定义 View 的实现原理，包含贝塞尔曲线、Matrix(矩阵)等 正文基础部分1. Android 中的坐标系因为比较基础，而且有总结的很好的：http://www.gcssloop.com/customview/CoordinateSystem 里边讲的内容大致分三点： 数学中的坐标系与手机屏幕中的坐标系的差别 View 的坐标系是相对于父控件而言的 MotionEvent 中 get 和 getRaw 的区别 2. 角度和弧度三方链接：http://www.gcssloop.com/customview/AngleAndRadian 角度和弧度一般会在制作一些复杂炫酷的效果时，会用到相关知识。 概念 ： 角度： 两条射线从圆心向圆周射出，形成一个夹角和夹角正对的一段弧。当这段弧长正好等于圆周长的360分之一时，两条射线的夹角的大小为1度. 弧度 ：两条射线从圆心向圆周射出，形成一个夹角和夹角正对的一段弧。当这段弧长正好等于圆的半径时，两条射线的夹角大小为1弧度. 3. 颜色三方链接：http://www.gcssloop.com/customview/Color 进阶部分1. 自定义 View 的分类和流程简介三方链接： http://www.gcssloop.com/customview/CustomViewProcess 2. Canvas 之绘制图形三方链接： http://www.gcssloop.com/customview/Canvas_BasicGraphics 主要介绍了常用的绘制图形，点、矩形、圆、椭圆等 关于画笔 Paint 的一些简要介绍 一个饼状图的案例 Canvas 的常用操作速查表： 3. Canvas 之画布操作三方链接： http://www.gcssloop.com/customview/Canvas_Convert 1. 位移 ( translate )translate 是坐标系的移动，可以为图形绘制选择一个合适的坐标系。 请注意，位移是基于当前位置移动，而不是每次基于屏幕左上角的 ( 0 , 0 ) 点移动 2. 缩放 ( scale )123public void scale (float sx, float sy)public final void scale (float sx, float sy, float px, float py) 这两个方法中前两个参数是相同的分别为x轴和y轴的缩放比例。而第二种方法比前一种多了两个参数，用来控制缩放中心位置的，第一种方法表示缩放的中心默认为坐标原点。 缩放是可以叠加的 3. 旋转 ( rotate )123public void rotate (float degrees)public final void rotate (float degrees, float px, float py) 和缩放一样，第二种方法多出来的两个参数依旧是控制旋转中心点的，默认的旋转中心依旧是坐标原点。 缩放也是可以叠加的 4. 错切 ( skew )1public void skew (float sx, float sy) float sx:将画布在 x 轴方向上倾斜相应的角度，sx 为倾斜角度的 tan 值， float sy:将画布在 y 轴方向上倾斜相应的角度，sy 为倾斜角度的 tan 值。 5. 快照 ( save ) 和回滚 ( restore ) 每调用一次save方法，都会在栈顶添加一条状态信息 4. Canvas 之图片文字三方链接： http://www.gcssloop.com/customview/Canvas_PictureText - 绘制图片有两种方法，drawPicture ( 矢量图 ) 和 drawBitmap ( 位图 )1. drawPicture 使用 Picture 前请关闭硬件加速，以免引起不必要的问题！ 1在 AndroidMenifest 文件中 application 节点下添上 android:hardwareAccelerated=”false” 以关闭整个应用的硬件加速。 可以把 Picture 看作是一个录制 Canvas 操作的录像机。 Picture 相关的 API beginRecording 和 endRecording 是成对使用的，一个开始录制，一个是结束录制，两者之间的操作将会存储在 Picture 中。 将 Picture 中的内容绘制出来可以有以下几种方法： 2. drawBitmap 获取 Bitmap 的方式： 绘制文字 常用 API 12345678910111213// 第一类public void drawText (String text, float x, float y, Paint paint)public void drawText (String text, int start, int end, float x, float y, Paint paint)public void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)public void drawText (char[] text, int index, int count, float x, float y, Paint paint)// 第二类public void drawPosText (String text, float[] pos, Paint paint)public void drawPosText (char[] text, int index, int count, float[] pos, Paint paint)// 第三类public void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)public void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint) 第一类只能指定文本基线位置(基线x默认在字符串左侧，基线y默认在字符串下方)。 第二类可以分别指定每个文字的位置。 第三类是指定一个路径，根据路径绘制文字。 绘制文字也需要画笔 Paint 链接中有 API 使用的详细介绍 5. Canvas 之 Path 的基本操作三方链接： http://www.gcssloop.com/customview/Path_Basic Path 的作用： 使用 Path 不仅能够绘制简单图形，也可以绘制这些比较复杂的图形。另外，根据路径绘制文本和剪裁画布都会用到Path 6. Path 之贝塞尔曲线三方链接： http://www.gcssloop.com/customview/Path_Bezier 1. 贝塞尔曲线的作用：贝塞尔曲线的运用是十分广泛的，可以说贝塞尔曲线奠定了计算机绘图的基础 ( 因为它可以将任何复杂的图形用精确的数学语言进行描述 ) ，在你不经意间就已经使用过它了。 2. 使用实例 7. PathMeasure三方链接： http://www.gcssloop.com/customview/Path_PathMeasure PathMeasure 是一个用来测量 Path 的类，主要有以下方法: 8. 矩阵 MatrixMatrix 原理： http://www.gcssloop.com/customview/Matrix_Basic Matrix 详解： http://www.gcssloop.com/customview/Matrix_Method Matrix Camera ： http://www.gcssloop.com/customview/matrix-3d-camera]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中的定时任务]]></title>
      <url>%2F2017%2F04%2F17%2FAndroid%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
      <content type="text"><![CDATA[前言 项目中有用到定时任务，就捎带着总结一下 本篇文章，一部分来自于 《第一行代码第2版》 本文着重说明下 Android 中的 Alarm 机制 正文一、Android 中实现定时任务的几种方式1. java 中的 Timer 类分享一个 Timer 详解链接： http://blog.csdn.net/zuolongsnail/article/details/8168689 Timer 类适合短期在后台运行的定时任务，而不适合长期的，因为现在的手机都有自己的休眠策略，Android 手机会在长时间不操作的情况下会自动让 CPU 进入到休眠状态，这就有可能导致 Timer 中的定时任务无法正常运行。 2. Handler分享一个链接： http://blog.csdn.net/dxpqxb/article/details/8659292 Handler post系列方法中有定时发送消息的操作，如：handler.postDelayed(); 3. Android 中的 Alarm 机制 Alarm 机制具有唤醒 CPU 的功能，它能保证在多数情况下需要执行定时任务的时候 CPU 都能正常工作，下面会详细介绍 Alarm 需要在 API 19 及其以上才能使用。 经测试，Alarm 有毫秒级别的误差 1234567891011121304-17 15:12:41.208 5615-5632/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:12:51.218 5615-5677/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:13:01.223 5615-5757/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:13:11.228 5615-5926/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:13:21.233 5615-6098/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:13:31.238 5615-6266/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:13:41.243 5615-6436/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:13:51.248 5615-6610/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:14:01.258 5615-6780/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:14:11.258 5615-6951/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:14:21.263 5615-7122/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:14:31.268 5615-7291/io.github.adsuper.timed_task I/Alarm: -+------------定时任务--------------04-17 15:14:41.273 5615-7466/io.github.adsuper.timed_task I/Alarm: -+------------定时任务-------------- 二、 Alarm 机制1. 核心类： AlarmManager1AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); 2. 调用 AlarmManager 的 set() 系列方法就可以设置一个定时任务123456long time = SystemClock.elapsedRealtime() + 10 * 1000;Intent intent1 = new Intent(this , LongRunningService.class);PendingIntent pendingIntent = PendingIntent.getService(this, 1, intent1, 0);alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP , time , pendingIntent); set 系列方法三个参数详解 第一个参数有四个选项分别为： 1234// AlarmManager.ELAPSED_REALTIME ,表示让定时任务的触发事件从系统开机开始算起，但是不会唤醒 CPU// AlarmManager.ELAPSED_REALTIME_WAKEUP ,表示让定时任务的触发事件从系统开机开始算起，但是会唤醒 CPU// AlarmManager.RTC ,表示让定时任务的触发事件从 1970 年 1 月 1 日 0 点开始算起，但不会唤醒 CPU// AlarmManager.RTC_WAKEUP ,表示让定时任务的触发事件从 1970 年 1 月 1 日 0 点开始算起，但会唤醒 CPU 第二个参数表示定时任务的触发时间： 如果第一个参数使用的是 ELAPSED_REALTIME 或者 ELAPSED_REALTIME_WAKEUP ，则这里就传入开机时间加上延迟执行的时间。 获取开机至今所经历的时间的毫秒数方法为：SystemClock.elapsedRealtime()； 如果第一个参数使用的是 RTC 或者 RTC_WAKEUP，则这里就传入从 1970 年 1 月 1 日 0 点至今所经历时间的毫秒数加上延迟执行的时间。 获取从 1970 年 1 月 1 日 0 点至今所经历的时间的毫秒数的方法为：System.currentTimeMillis(); 第三个参数是一个 PendingIntent ，表示一个后台可以长时间运行的服务 set() 和 setExact() 的区别 从 Android 4.4 系统开始，Alarm 任务的触发事件将会变得不准确，有可能会延迟一段时间后任务才能执行，但这并不是 bug，而是系统在耗电方面进行的优化。系统会自动监测目前有多少个 Alarm 任务存在，然后触发时间相近的几个任务会放在一起执行，这就可以大幅度减少 CPU 被唤醒的次数，从而有效延长电池的使用时间。 如果要求 Alarm 任务的执行时间必须准确无误，Android 仍然提供了解决方案，使用 setExact() 方法来代替 set() 方法。 3. 完整的代码 Activity 中 1234567891011121314151617181920212223242526package io.github.adsuper.timed_task;import android.app.AlarmManager;import android.app.PendingIntent;import android.content.Context;import android.content.Intent;import android.os.SystemClock;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import java.util.Timer;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //开启一个服务 Intent intent = new Intent(this,LongRunningService.class); startService(intent); &#125;&#125; Service 中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package io.github.adsuper.timed_task;import android.app.AlarmManager;import android.app.PendingIntent;import android.app.Service;import android.content.Context;import android.content.Intent;import android.os.IBinder;import android.os.SystemClock;import android.support.annotation.IntDef;import android.support.annotation.Nullable;import android.util.Log;public class LongRunningService extends Service &#123; private AlarmManager alarmManager; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //执行具体的定时逻辑操作 //逻辑操作也是需要耗时的，如果放在主线程中，可能会对定时任务的准确性造成轻微的影响 Log.i(&quot;Alarm&quot;,&quot;-+------------定时任务--------------&quot;); &#125; &#125;).start(); alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); long time = SystemClock.elapsedRealtime() + 10 * 1000; Intent intent1 = new Intent(this , LongRunningService.class); PendingIntent pendingIntent = PendingIntent.getService(this, 1, intent1, 0); alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP , time , pendingIntent); return super.onStartCommand(intent, flags, startId); &#125;&#125; 4. 另外需要注意的事项 取消定时任务 12//pendingIntent 要跟设置的时候一致才能取消alarmManager.cancel(pendingIntent); Alarm 也能定时发送广播 12// 参数与 set() 类似alarmManager.setRepeating(); 还有一系列其他的操作，有待发掘]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio 项目混淆、打包、签名、发布一条龙]]></title>
      <url>%2F2017%2F04%2F14%2FAndroidStudio%E9%A1%B9%E7%9B%AE%E6%B7%B7%E6%B7%86%E3%80%81%E6%89%93%E5%8C%85%E3%80%81%E7%AD%BE%E5%90%8D%E3%80%81%E5%8F%91%E5%B8%83%E4%B8%80%E6%9D%A1%E9%BE%99%2F</url>
      <content type="text"><![CDATA[前言本篇文章介绍的是一个 AndroidStudio 项目完成之后，发布到各大应用市场所需要的所有操作，当然，也可能不是很全 正文android 项目发布到各大应用市场一般分为四个步骤：混淆、打包、签名、发布，本篇文章就针对这四步进行分析总结！ 一、混淆混淆的目的是为了防止我们的 APP 被反编译，从而泄漏源码，而混淆也不是绝对的，世上无难事，只怕有心人呐！ 1. modul 级别的 build.gradle中的 release 节点下的为混淆配置，如下所示：12345678buildTypes &#123; release &#123; //是否开启混淆 minifyEnabled false // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125;&#125; 以上代码，是项目刚刚建立时的默认的混淆配置，而我们要发布到应用市场，一般需要改成如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243def releaseTime() &#123; return new Date().format(&quot;yyyy.MM.dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))&#125;android &#123; buildTypes &#123; debug &#123; // 显示Log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot; //// apk包名称后缀，用来区分release和debug versionNameSuffix &quot;-debug&quot; minifyEnabled false zipAlignEnabled false shrinkResources false signingConfig signingConfigs.debug &#125; release &#123; // 不显示Log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot; // 混淆 minifyEnabled true // Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.release //修改输出文件名称 applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123; // 输出apk名称为appname-1.0-release-xxxx-xx-xx.apk def fileName = &quot;app-$&#123;defaultConfig.versionName&#125;-release-$&#123;releaseTime()&#125;.apk&quot; output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125;&#125; 2. proguard-rules.pro ( 自定义的混淆文件 )在上边的 1 中 有这样一行代码: 12 // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; 这个文件就是自定义的混淆文件，我们可以编辑里边的内容，改变我们项目的混淆配置，这些配置是固定的，网上能搜到很多，我就直接附上几条不错的链接： https://my.oschina.net/aibenben/blog/371889 http://www.jianshu.com/p/f9438603e096 混淆到此结束！ 二、打包 - 多渠道打包现在大大小小的 Android 应用市场大概有 100 多家，这也是要多渠道打包的原因，我们可以根据自己的需要，打包为不同应用市场的 APK ，配置方式如下：以友盟统计为例 1. 登录 友盟 官网，注册账号，在产品栏里找到 应用统计 ，点击之后，点击立即使用，在左下方有个添加新应用，然后获取 AppKey ！2. 在 app 的 build.gradle 文件中添加以下配置：123dependencies &#123; compile &apos;com.umeng.analytics:analytics:latest.integration&apos;&#125; 3. 在 AndroidManifest.xml 中配置 AppKey (第一步中获取的 AppKey)123456789101112131415//添加所需的相关权限&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; &lt;application //在 application 节点下添加，需要把 AppKey 替换掉，其他不需要改 &lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;AppKey&quot; /&gt; &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt; &lt;/application&gt; 4. 在 app 的 build.gradle 设置 productFlavors实际上就是针对不同应用市场的 apk 的设置，如下： 1234567891011121314151617181920android &#123; //注意是在 android 节点下 productFlavors &#123; googleplay &#123;&#125; huawei &#123;&#125; xiaomi &#123;&#125; wandoujia &#123;&#125; baidu &#123;&#125; yingyongbao &#123;&#125; android360 &#123;&#125; uc &#123;&#125; umeng &#123;&#125; meizu&#123;&#125; //批量配置 productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] &#125; &#125;&#125; 当然也可以添加其他的应用市场！ 5. 在 AndroidStudio 下方 有个 Terminal 命令行输入，在其中输入命令 gradlew assembleRelease ，然后就静静等待完成，完成后如下所示： 这是还未签名的 apk 还有一些其他的命令： 123gradlew assembleRelease //创建新任务打包所有渠道包的release版本apkgradlew assembleDebug //创建新任务打包所有渠道包的debug版本apkgradlew assemblebaiduRelease //创建新任务打包指定渠道包(百度)的release版本apk 本人在这里碰到一个问题： 打包失败提示： Unsupported major.minor version 52.0 解决方法：将 JDK 换为 1.8 并更改环境变量配置，然后重启 AndroidStudio ，重新打包，成功！ 三、签名要想把 apk 发布到各大应用市场，签名是必须的，签名就像版权一样，证明这是谁开发的！操作如下： ==第一种方式：==1. 在 AndroidStudio 的菜单栏上依次选择 Build -&gt; Generate Signed APK 我这上边是已经有了一个签名文件 2. 如果没有签名文件就点击 Creat new… 各个选项的含义为： 123456789Key store path：密钥库文件的地址Password/Confirm：密钥库的密码Alias：密钥名称Password/Confirm：密钥密码Validity(years)：密钥有效时间，一般默认25年First and Last Name：密钥颁发者姓名Organizational Unit：密钥颁发组织City or Locality：城市Country Code(XX)：国家代码 3. 点击下方 OK 之后就回到了第一步的界面 4. 点击 Next 5. 点击 Finish 之后，就会在保存的路径内找到对应的 apk==第二种方式：==在 app 的 build.gradle 中的 android 节点下添加如下代码： 123456789101112131415161718signingConfigs &#123; debug &#123; keyAlias &apos;nicai&apos; keyPassword &apos;nicai&apos; storeFile file(&quot;nicai.jks&quot;) storePassword &apos;nicai&apos; &#125; release &#123; //key别名 keyAlias &apos;nicai&apos; //key密码 keyPassword &apos;nicai&apos; //密钥文件路径 storeFile file(&quot;nicai.jks&quot;) //密钥文件密码 storePassword &apos;nicai&apos; &#125;&#125; 四、发布到各大应用市场首先要去各大应用市场的平台注册开发者，需要身份证等证明照片！ 1. 上传，需要准备一些必备的东西 签名过的apk（要保存好生成的证书，下次更新的时候要用）； 图标icon，必备的是1616，和512512这两种尺寸。其他的也可以准备； App截图：准备3~5张，基本每个平台都需要； 应用介绍：用几十个字简短介绍你的App，基本每个平台都需要； 当前版本介绍：介绍你当前的版本或者更新版本的一些情况，如修复了哪些bug等等； 应用的分类：这个你事先想好你的App是属于哪种类型的； 应用关键字：选3~5个关键字描述你的App； 如果是公司开发者的话还需要营业执照和法人执照。 2. 认领每个应用市场需要的东西并不完全一样，但是一般只要有公司营业执照，代码截图，apk，基本都能认领成功 3. 审核各大应用市场的审核规则不是完全一样，很多都要求不能有广告，审核时间也不一样，有的快，有的慢，多联系客服！ 至此，完结，欢迎指正！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[drawable 和 mipmap 不得不说的故事]]></title>
      <url>%2F2017%2F04%2F13%2Fdrawable%E5%92%8Cmipmap%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[一、图片到底存到哪个目录下 Google 官方推荐，mipmap 文件夹下仅仅存放应用启动图标 其他的 png 图片和 .9.png 等图片还是存放在相应的 drawable 目录 二、如何自动创建响应的 drawable 目录AndroidStudio 项目默认只有一个 drawable 目录，而没有对应的 -hdpi 等目录，解决方式如下： 需要修改 androidStudio 的默认配置文件 定位到 androidStudio 的安装目录：C:\Program Files\Android\Android Studio\plugins\android\lib\templates\gradle-projects\NewAndroidModule 修改该文件夹下的 recipe.xml.ftl 文件 大概在 28 行的原文件一部分为： 123456789101112131415&lt;#if !(isInstantApp!false) || (isBaseAtom!false)&gt; &lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable&quot; /&gt; &lt;#if copyIcons &amp;&amp; !isLibraryProject&gt; &lt;#if buildApi gte 25 &amp;&amp; targetApi gte 25&gt; &lt;copy from=&quot;root/res/mipmap-hdpi/&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-hdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-mdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-mdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-xhdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-xhdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-xxhdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-xxhdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-xxxhdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-xxxhdpi/&quot; /&gt; &lt;#else&gt; 在 &lt;mkdir 这一行之后添加如下代码： 1234&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-hdpi&quot; /&gt;&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-mdpi&quot; /&gt;&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-xhdpi&quot; /&gt;&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-xxhdpi&quot; /&gt; 重启 androidStudio ，然后新建项目，就会发现已经有对应的 drawable 目录了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中的单例模式总结]]></title>
      <url>%2F2017%2F04%2F13%2FAndroid%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%98%2F</url>
      <content type="text"><![CDATA[前言：简单来说，设计模式就是前人留下的一些经验的总结，把这些总结分类为不同的设计模式，通过使用这些模式，使我们的代码看起来更加简洁，复用性更高，可维护性更高，是 Android 进阶之路必不可少的一环！ 正文：单例模式的写法，大概分为以下六种： 1. 饿汉式1234567891011121314public class SingletonText &#123; public static SingletonText singletonText = new SingletonText(); //私有化构造方法 private SingletonText()&#123; &#125; public static SingletonText getInstance()&#123; return singletonText; &#125;&#125; 这种方式，简单粗暴，并且是线程安全的，主要适用于在初始化时，就要用到单例的情况，并且单例对象初始化速度很快，占内存比较小，不影响程序的启动速度，但是在实际项目中的单例模式不会这么简单，所以，一般用的不多！ 2. 懒汉式123456789101112131415161718public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText()&#123; &#125; public static SingletonText getInstance()&#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; return singletonText; &#125;&#125; 懒汉式，是在需要的时候才会做初始化单例对象的操作，适用于，初始化时，耗费时间较长，资源较多，不宜在程序启动时初始化，而且在多线程的环境下，并不是线程安全的。 3. 线程安全下的懒汉式-同步锁12345678910111213141516171819public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText()&#123; &#125; //添加 synchronized 关键字 public static synchronized SingletonText getInstance()&#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; return singletonText; &#125;&#125; 或者： 12345678910111213141516171819202122public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText()&#123; &#125; //添加 synchronized (SingletonText.class)&#123;&#125; public static SingletonText getInstance()&#123; synchronized (SingletonText.class)&#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; return singletonText; &#125; &#125;&#125; 4. 双重检验锁123456789101112131415161718192021222324public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText() &#123; &#125; public static SingletonText getInstance() &#123; if (singletonText == null) &#123; synchronized (SingletonText.class) &#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; &#125; &#125; return singletonText; &#125;&#125; 在 synchronized (SingletonText.class) {} 之前加上 if (singletonText == null) 判断，减少获取锁的次数，从而提高性能，而这种也用的较多 5. 静态内部类1234567891011121314151617public class Singleton &#123; public static class SingletonText &#123; public static SingletonText singletonText = new SingletonText(); //私有化构造方法 private SingletonText() &#123; &#125; public static SingletonText getInstance() &#123; return SingletonText.singletonText; &#125; &#125;&#125; 只要程序中不使用这个内部类，就不会加载，从而实现了饿汉式的延迟加载，并且也是线程安全的。 6. 枚举实际上 Google 并不推荐使用枚举，因为与 class 相比，相同的静态常量，枚举占用的内存较多，个人认为，一旦涉及到内存，就算再方便也不能用，毕竟 Android 内存不多啊！ 总结：一共介绍了以上 6 种单例模式的书写方式，各有各的用途，看需求选择吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lottie 在 Android中的用法初探]]></title>
      <url>%2F2017%2F04%2F11%2FLottie%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[一、概述 Lottie 是一个由 Airbnb 开源的第三方动画库，它能够同时支持 iOS，Android 与 ReactNative 的开发； Lottie 通过 AE ( After Effects ) 中的 Bodymovin 插件将 AE 中制作好的动画导出成一个 json 文件，这个 json 文件就是我们需要的动画。 在 github 上有几种动画效果和源码介绍：https://github.com/airbnb/lottie-android CSDN 上也有一篇博文讲的不错：http://blog.csdn.net/trojx2/article/details/54896899 二、 AE 是什么 反正本人刚看到这个词的时候一脸懵逼，还专门去搜索了 - -！ Adobe After Effects ，没错，就是这个软件，由 Adobe 公司提供更新的，目前最新版本为 CC(13.5)。 由上边的这个软件来制作动画，然后导出为 json 格式的文件。 三、用法 本人目前并不会使用 AE ，而且， AE 还是收费软件，所以就在 github 上找了 json 文件，以写 demo 的形式来练习使用 1、 在概述中的 github 中找到 sample 文件中的 app/src/main/assets 目录下的 json 文件，随便选择一个，导入到自己项目的 assets 文件夹下2.在 app 的 build.gradle 中 添加如下依赖：123dependencies &#123; compile &apos;com.airbnb.android:lottie:2.0.0-beta4&apos;&#125; 3. 在布局文件中添加使用12345678&lt;com.airbnb.lottie.LottieAnimationView android:id=&quot;@+id/lottie&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:lottie_fileName=&quot;hello_AE.json&quot; app:lottie_loop=&quot;true&quot; app:lottie_autoPlay=&quot;true&quot; /&gt; 也可以在代码中使用，但是不知道为嘛代码方式老是找不到 assets 目录中的 json 文件 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RSA 算法 + AES 算法在 Android 中结合使用]]></title>
      <url>%2F2017%2F04%2F05%2FRSA%E7%AE%97%E6%B3%95-AES%E7%AE%97%E6%B3%95%E5%9C%A8Android%E4%B8%AD%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[前言加密算法在网络应用中越来越广，为了保证网络请求数据的安全，Android 网络请求中也越来越多的加入加密算法，本文主要是记录 RSA 和 AES 算法在 Android 中的应用 正文一、 概念1. RSA 算法 RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用 RSA 加密的信息实际上是不能被解破的。 RSA 算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey），公钥加密，私钥解密；私钥加密，公钥解密。 随机生成一对公钥和私钥，客户端拿公钥，服务端拿私钥。 2. AES 算法 该算法为比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，结合两位作者的名字，以 Rijndael 为名投稿高级加密标准的甄选流程。 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES。 每次用的时候随机生成一个秘钥，用完之后销毁 二、 使用流程1. 客户端和服务端用的 base64 加密类要一致，这个加密类是一个 jar 包，java 中有自带的 Base64 算法类，但是安卓中却没有，如果不统一 jar 包，解析要出错12javabase64-1.3.1.jar 2. 客户端使用示例代码操作步骤： 客户端随机产生 AES 的密钥 对身份证信息（重要信息）进行 AES 加密 通过使用 RSA 对 AES 密钥进行公钥加密 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; //需要加密的重要信息 private String name = &quot;zhangsan&quot;; private String idCard = &quot;4103271991***&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 加密-------------- */ // AES 产生的随机秘钥 String key = AESUtils.generateKey(); //加密之后的重要信息 String encryptName = AESUtils.encryptData(key, name); String encryptIdCard = AESUtils.encryptData(key, idCard); //对 AES 秘钥进行 RSA 加密 String encryptByPublicKey = RSAUtils.encryptByPublicKey(key); Log.i(&quot;RSAAndAES&quot;,&quot;AES秘钥为::::&quot;+key); Log.i(&quot;RSAAndAES&quot;,&quot;encryptName为::::&quot;+encryptName); Log.i(&quot;RSAAndAES&quot;,&quot;encryptIdCard为::::&quot;+encryptIdCard); Log.i(&quot;RSAAndAES&quot;,&quot;encryptByPublicKey为::::&quot;+encryptByPublicKey); &#125; 其中，RSA 的秘钥和公钥是提前生成好的，例如：1234567891011121314151617181920公钥： MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2Hy8d1jGGVlxNa3FEfeY5x9i5RxgICZvV/GO ekpyK/FxU+K44ft3EiUKGE12BS74lcO4j/1iIgbXV6CuonULSIzBwC52o7v2gFSW/5k+Mms 82q0OKu82Oosj2qYD+mlbfeCHxgPrdUwSeYxGWh1u/uM6r1hEkv9pKov+jWqyNuwIDAQAB私钥： MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALYfLx3WMYZWXE1rcUR95jnH2LlH GAgJm9X8Y56SnIr8XFT4rjh+3cSJQoYTXYFLviVw7iP/WIiBtdXoK6idQtIjMHALnaju/aAVJb/ mT4yazzarQ4q7zY6iyPapgP6aVt94IfGA+t1TBJ5jEZaHW7+4zqvWESS/2kqi/6NarI27AgMBAA ECgYBlbA5gLlWcO2Hh15DXlMluqiW+YKI4b6lyTMDpoTo+iHWe+HKFkdlMxyfd5NDw3U6CKVblg yE5vAqYmlgd6Z442cKtkiuFaBe6A6P2VHr8YLCVmB6QgRenASO4fCWqi5quEq/IvPhRpshRyuuJ cDnziMKx03RnEfZQRSbaK9K3cQJBANzxF1GoOdLsUmSaExhJKnirWXPsDbpu6IBmqUZdXQYDDmv hs0DJw/JQnuv0gm/gv6Qjy/v3fNHUFcPsQh0undMCQQDTBS6QjYU/2LKQ/RFoTTxLKrcPg3o66B 794jXR+kqLXJDO/UD88EMHHfOWo/QWVZvgdzQCGBErXk+rb41a8hd5AkEAxblUnxUnumUXT0S7d e50fc0Knr1Pg9qhY9d8AaaoCytNCqrPmll2bDJOJueIm8rMdn46nOFc6QMd/1o9yJPhVQJAVWGS XrC0SooObjXHFlGx5KQK378N9Mm4yHb/2c8Q3GR+vxGfevhn1nha+AesmmDXKjJxG6vLPqXxTGd dZX/w2QJBAM5jrVojC5mXQnA1eKzzRSCeAx97vzZX8wZpwqKVHmazd2kayUjzSARkm+P76+sB0G 96kGQJCRm7jEdl5jh5o2s=私钥的长度要比公钥长的多 Log 打印出来的结果大概是这样：123456AES秘钥为::::ecf82772a1ab4282encryptName为::::9ZaVuJNAKKwOpm7o+k0Tsg==encryptIdCard为::::DZ970wYy78lxpGfl0m3ziQ==encryptByPublicKey为::::iLAfMtFq23q+9AIp02KTO9KKq1kmeaN9E41evXJ7UZY7/c4FC2o1SadDZeB/EA6C9yurGI0X9HQhxtJC5JXwyEU2OVRqIx75a/ILaYyJ+AiJb06F/L/xfIS7nZBnb04dY65Bvbg1imr6SESKPuQOX5mJdgpbJZ0Vp2lj0ZGylbw= 3. 服务端使用代码示例操作步骤： 对加密后的 AES 密钥进行 RSA 私钥解密，拿到密钥原文； 对加密后的重要信息进行 AES 解密，拿到原始内容 123456 // 通过 RSA 私钥 还原 AES 秘钥String AESKEY = RSAUtils.decryptByPrivateKey(encryptByPublicKey);//通过 AES 秘钥 还原数据String name1 = AESUtils.decryptData(AESKEY, encryptName);String idCard1 = AESUtils.decryptData(AESKEY, encryptIdCard); 三、 为什么要两种算法配合使用 上边的例子大概是：客户端加密向服务端请求数据，服务端解密的过程。 而这种过程完全用 RSA 加密也能做到，两种算法结合的原因就是：AES 加密算法的解密速度要比 RSA 快得多，大概100倍。 还有一个原因：两种算法，多个秘钥，更加有利于信息安全。 四、 第三方链接 参考博文：http://www.10tiao.com/html/227/201704/2650239103/1.html 工具方法下载的第三方链接(不是本人)://download.csdn.net/detail/chay_chan/9766486]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dagger2 在 Android 中的使用]]></title>
      <url>%2F2017%2F03%2F30%2Fdagger2%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[前言dagger2 确实比较难上手，而我在写笔记之前也没完全整明白，只能记录些简单的应用 正文一、dagger2 是什么？dagger2 是依赖注入(Dependency Injection 简称 DI )框架中的一种，在编译期间自动生成代码，负责依赖对象的创建，貌似是目前最好的 DI 框架了。 二、为什么要用这玩意1. 增加开发效率，省去重复代码它可以把 new 对象的重复性工作做了，也能省去写单例方法的时间，也不用考虑单例模式的线程是否安全，因为这些都是 dagger2 的工作。 2. 进一步解耦 先说“解耦”的概念：解耦是为了让类与类、模块与模块之间的相互影响的关系降到最低，并不是说完全没有关系。 如果我们是通过 new 来创建对象的，那么当被 new 的对象所在的类的构造方法发生改变时，那么该类涉及到的类都要去修改，而 使用 dagger2 就不存在这方面的问题了。 3.方便测试三、如何使用1. 添加插件和依赖 在工程目录下的 bulid.gradle 中添加 apt 插件 12345dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;&#125; 在 项目目录下的 bulid.gradle 中添加依赖 1234//版本最好匹配apt &apos;com.google.dagger:dagger-compiler:2.2&apos;compile &apos;com.google.dagger:dagger:2.2&apos;provided &apos;org.glassfish:javax.annotation:10.0-b28&apos; 2. 简单使用现在有这么一个场景： 一个类为： 123456789101112//注意：构造方法没有参数public class Hello &#123; public Hello()&#123; &#125; public String getSmg()&#123; return &quot;Hello,World!&quot;; &#125;&#125; 另一个类为： 12345678910public class MainActivity extends AppCompatActivity &#123; Hello hello;//我们要这个 hello 的对象 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; 那么，在 MainActivity 中要 Hello 类的对象，我们该怎么做？（除了 new ） 第一步 ：我们要在 Hello 类中用 @Inject 标注构造函数 1234@Injectpublic Hello()&#123;&#125; 第二步：在 MainActivity 中也添加 @Inject 123@InjectHello hello;//注意，不能用 private 修饰 第三步：需要一个 Component 作为连接 12345678//HelloComponent 可以是接口或者抽象类@Component()public interface HelloComponent &#123; //方法是固定写法，参数是因为要注入到 MainActivity 中 void inject(MainActivity activity);&#125; 第四步：还需要在 MainActivity 中做一些初始化操作 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Inject Hello hello; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化操作，注意被注入的 Hello 的构造方法是没有参数的 HelloComponent component = DaggerHelloComponent.builder() .build(); component.inject(this); &#125; 第五步：这样就把 Hello 对象 注入到 MainActivity 中了，可以验证一下 3. 如果被注入的类的构造方法有参数呢，那就要引入 ModuleModule 其中一个作用是为 构造方法提供参数用的， 我现在把 Hello 类的构造方法加上参数 123456789101112public class Hello &#123; @Inject public Hello(String msg)&#123; &#125; public String getSmg()&#123; return &quot;Hello,World!&quot;; &#125;&#125; 跟没有参数的构造方法相比，还要多加一步 1234567891011// 创建一个 XXXModule 要用 @Module 标注@Modulepublic class HelloModule &#123;//创建一个 providesXXX 方法，要用 @Provides 标注，返回值类型就是 Hello 构造方法的参数类型 @Provides public String providesReturnMessage()&#123; return &quot;Hello,World!&quot;; &#125;&#125; 同时， HelloComponent 也要做修改 123456789// @Component 后边加的东西，modules = 是固定写法 ， HelloModule.class 表示需要注入的类@Component( modules = HelloModule.class)public interface HelloComponent &#123; void inject(MainActivity activity);&#125; 另外 MainActivity 也要修改 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Inject Hello hello; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); HelloComponent component = DaggerHelloComponent.builder() //跟之前的相比，多了 .helloModule(new HelloModule()) //这样一来，就串在一起了 .helloModule(new HelloModule()) .build(); component.inject(this); &#125; 运行之后，也是对的 当然 dagger2 还有很多其他的注解和用法，以上是最简单的 Demo ，本人也没有在项目中实践过，无法提供更多的用法！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio中使用butterknife]]></title>
      <url>%2F2017%2F03%2F27%2FAndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8butterknife%2F</url>
      <content type="text"><![CDATA[前言全程鼠标和快捷键操作，不需要手动添加一行代码！ 正文 butterknife 的 github 地址： https://github.com/JakeWharton/butterknife 一、使用原因butterknife 主要是为了解决 findViewById 和 onClick 的重复和繁琐，提高我们的编码效率而出现的。 缺点：虽然说 findViewById 比较繁琐，但是我们一看就明白，而通过注解的方式，个人觉得代码的阅读性会变差，但是随着熟练度的增加，这个缺点也可以忽视了。 二、使用方法1. 打开 Android Studio 的设置页面下载插件 Android ButterKnife Zelezny ，安装完毕后重启 Android Studio ，如下图所示： 2.在 Activity 或者 Fragment 中，鼠标放在资源文件上，快捷键 Alt+Insert ，或者鼠标右键选择，选择 Generate ，如下图所示： 3.在 app 下的 bulid.gradle 中添加如下依赖：1234567dependencies &#123; compile &apos;com.jakewharton:butterknife:8.5.1&apos; compile &apos;com.jakewharton:butterknife-compiler:8.5.1&apos; //8之前只需要第一个依赖就行了，8之后需要这两个依赖&#125; 也可以使用图形化界面添加依赖：打开 file - Project Structure -选中 app -切换到 Dependencies - 点击右侧加号 - 搜索 butterknife ， 如图所示： 4.选择 Generate Butterknife Injections 之后，会弹出以下窗口： 其中：onClick 选项为：是否添加点击事件。Variable Name 表示：生成的变量名称。Creat ViewHolder 表示：是否创建为 ViewHolder。Split Onclick methods 表示：点击事件分开或者合并。 5.创建完成之后，如下方图片和代码所示： 123456789101112131415161718192021222324252627 @BindView(R.id.text_1)TextView text1;@BindView(R.id.text_2)TextView text2;@BindView(R.id.btn_1)Button btn1;@BindView(R.id.btn_2)Button btn2;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this);&#125;@OnClick(&#123;R.id.btn_1, R.id.btn_2&#125;)public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.btn_1: break; case R.id.btn_2: break; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中 Retrofit2.X 的使用(1)]]></title>
      <url>%2F2017%2F03%2F27%2FAndroid%20%E4%B8%AD%20Retrofit2.X%20%E7%9A%84%E4%BD%BF%E7%94%A8(1)%2F</url>
      <content type="text"><![CDATA[前言本文只是 Retrofit Android 端的常规使用 正文一、Retrofit 简介Retrofit 是 Square 公司开源的一个网络请求框架，适用于 Android 和 java ，采用注解的方式，简化网络请求，提高网络请求速度，底层为 Square 公司的 okhttp ！ 二、主要的请求方式和注解简介1. 主要的请求方式 格式 含义 @GET 表示这是一个GET请求 @POST 表示这个一个POST请求 @PUT 表示这是一个PUT请求 @DELETE 表示这是一个DELETE请求 @HEAD 表示这是一个HEAD请求 @OPTIONS 表示这是一个OPTION请求 @PATCH 表示这是一个PAT请求 2. 主要的注解 格式 含义 @Headers 添加请求头 @Path 替换路径 @Query 替代参数值，通常是结合get请求的 @FormUrlEncoded 用表单数据提交 @Field 替换参数值，是结合post请求的 三、简单使用例子1. 添加依赖和权限123//这两个依赖的版本要一致compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; 12//添加网络请求权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt; 2. 创建网络请求接口12345678910111213import retrofit2.Call;import retrofit2.http.GET;import retrofit2.http.Path;import retrofit2.http.Query;//接口名称，随意命名public interface RetrofitText &#123; //@GET 表示是get请求 ， 而 @GET 后边括号里的是相对 @GET(&quot;sapientialMall/getLadderInfo.action&quot;) Call&lt;RetrofitTextBean&gt; getRequest(@Query(&quot;market_id&quot;) int markret_id , @Query(&quot;floor_start&quot;) int floor_start , @Query(&quot;floor_end&quot;) int floor_end ); &#125; 说明： 这是一个接口，接口名称随意命名 @GET 表示是 get 请求 ， 而 @GET 后边括号里的是相对地址，例如：www.baidu.com/aaaa/bbbb/ccccc ，其中 aaaa/bbbb/ccccc 就是相对地址。 Call 是固定写法，后边&lt;&gt;中的 RetrofitTextBean 是根据请求结果的 json 字符串生成的 javaBean getRequest 方法名一般采用 getXXX的形式 @Query 是配合 GET 请求用的，后边的括号内为拼接在 url 后的请求参数 key ，而 int 类型的 markret_id 为 value 3. 开始异步请求 （ GET 请求）123456789101112131415161718192021222324//1.创建 Retrofit 实例，并完成相关配置Retrofit retrofit = new Retrofit.Builder()//baseUrl 为 www.baidu.com/aaaa/bbbb/ccccc 中的 www.baidu.com/ .baseUrl(baseUr) //表示调用 Gson 库来解析返回值，将结果直接解析为 javaBean 对象 .addConverterFactory(GsonConverterFactory.create()) .build();//2.创建接口对象，即 RetrofitText 接口的对象RetrofitText retrofitText = retrofit.create(RetrofitText.class);//3.获取请求服务方法Call&lt;RetrofitTextBean&gt; call = retrofitText.getRequest(1, 5, -3);//4.开始异步请求call.enqueue(new Callback&lt;RetrofitTextBean&gt;() &#123; @Override public void onResponse(Call&lt;RetrofitTextBean&gt; call, Response&lt;RetrofitTextBean&gt; response) &#123; //请求成功 &#125; @Override public void onFailure(Call&lt;RetrofitTextBean&gt; call, Throwable t) &#123; //请求失败 &#125;&#125;); 四、GET 请求扩展（以第三条的例子为基础）1. 另一种接口定义方式123456789101112131415import retrofit2.Call;import retrofit2.http.GET;import retrofit2.http.Path;import retrofit2.http.Query;import retrofit2.http.Url;public interface RetrofitText &#123; @GET(&quot;&quot;) Call&lt;RetrofitTextBean&gt; getRequest2(@Url String url , @Query(&quot;market_id&quot;) int markret_id , @Query(&quot;floor_start&quot;) int floor_start , @Query(&quot;floor_end&quot;) int floor_end );&#125; 说明： 这种定义方式，是在获取请求方法的时候才传入相对地址，更加灵活一点，如下所示： 1Call&lt;RetrofitTextBean&gt; call = retrofitText.getRequest2(&quot;这里是相对地址&quot;, 1, 5, -3); 2. 还有一种接口定义方式12@GET(&quot;sapientialMall/getLadderInfo.action&quot;)Call&lt;RetrofitTextBean&gt; getRequest4(@QueryMap Map&lt;String , Integer &gt; map); 说明： 这种适合参数比较多，且参数的数据类型一致时，使用 未完待续~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中的消息机制--Handler]]></title>
      <url>%2F2017%2F03%2F24%2FAndroid%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler%2F</url>
      <content type="text"><![CDATA[前言网上关于Handler机制运行原理的文章已经很多，但毕竟不是自己的，也不一定适合自己的阅读习惯！ 一、概述 Android 的消息机制主要是指 Handler 的运行机制， Handler 的运行需要底层的 MessageQueue 和 Looper 支撑，这三者实际上是一个整体 ( 配套使用 ) ，只不过我们在开发过程中比较多的接触到 Handler 而已。 说到 Handler ，很多人都知道是为了更新 UI ，这不错，但这只是 Handler 的一个应用场景而已。 Handler 出现的原因，我想是因为不能在主线程中做耗时操作，一旦耗时操作超过 5s 就会出现 ANR 异常，下面代码是 Handler 的最常用用法: 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; private Handler myHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //主线程中处理发送过来的message &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //子线程中发送Handler消息 new Thread()&#123; @Override public void run() &#123; Message msg = new Message(); msg.what = 1; myHandler.sendMessage(msg); &#125; &#125;.start(); &#125; &#125;&#125; 注意： 线程中默认是没有 Looper的，如果想要使用 Handler 就必须为线程创建 Looper ，否则会报错，Looper 是运行在 Handler 所在的线程中的。 主线程比较特殊，它在创建的时候就会初始化 Looper，会调用 Looper.prepaerMainLooper() 来创建主线程的 looper 以及 MessageQueue ，也就是说，在主线程中默认可以使用 Handler 。 大致的原理： Handler 通过 send 或 post 的 一系列方法发送 message 到 MessageQueue 。 MessageQueue 翻译过来叫做消息队列，内部存储 Handler 发送过来的一系列消息，仅仅能存储消息，数据存储结构为单链表。 Looper 会以无限循环的方式从 MessageQueue 中查找是否有新消息，如果有就处理消息，否则就一直等待着。 二、详细分析主要介绍下 ThreadLocal 、 Handler 、 MessageQueue 、Looper 1. ThreadLocalThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只能在指定线程中才可以获取到存储的数据。 介绍 ThreadLocal 是因为不同线程的 Handler 获取对应 Looper 采用的就是这个原理。 举个例子： 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; //ThreadLocal 对象，存储的是 boolean 值 private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBooleanThreadLocal.set(true); Log.i(&quot;Thread---Main:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); new Thread(&quot;Thread---1&quot;)&#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.i(&quot;Thread---1:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); &#125; &#125;.start(); new Thread(&quot;Thread---2&quot;)&#123; @Override public void run() &#123; Log.i(&quot;Thread---2:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); &#125; &#125;.start(); &#125; 代码中，在主线程中设置 mBooleanThreadLocal 为 true ，在 Thread—1 中设置 mBooleanThreadLocal 为 false ，在 Thread—2 中没有设置， mBooleanThreadLocal 通过 set() 和 get() 方法进行数据的设置和取出操作。 打印出来的结果为： 12312945-12945/? I/Thread---Main:: true12945-12959/? I/Thread---1:: false12945-12960/? I/Thread---2:: null 从上边的日志可以看出，在不同线程中访问同一个 ThreadLocal 对象，获得的值却是不一样的，原因就是：ThreadLocal 内部会从各自的线程中取出一个数组，然后再从数组中根据当前 ThreadLocal 的索引去查找对应的 value 值，而不同线程中的数组是不同的，所以取出的值也不一样。 2. MessageQueue翻译过来为消息队列，其主要包含两个操作：插入和读取，分别对应 MessageQueue 的两个方法 enqueueMessage() 和 next() ，另外，读取过的消息会删除掉！ 3. LooperLooper 会不停的从 MessageQueue 中查看是否有新消息，有就立刻处理，否则就一直阻塞，在 Looper 的构造方法中会创建一个 MessageQueue 对象，再次印证了那四个字—配套使用。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 除了主线程之外，在其他线程中如何创建 Looper 对象，如下所示： 1234567891011121314new Thread(&quot;Thread---1&quot;)&#123; @Override public void run() &#123; //创建 Looper 对象 Looper.prepare(); Message msg = new Message(); msg.what = 1; myHandler.sendMessage(msg); //开启消息循环 Looper.loop(); &#125; &#125;.start(); 获取主线程 Looper， 通过方法：Looper.getMainLooper(); Looper 退出，有两个方法，Looper 的 quit() 和 quitSafely() ，其内部还是让 MessageQueue 的 next 方法返回 null ， next 方法返回 null 是唯一的退出方式 ，建议不需要的时候终止 Looper。 quit() 是直接退出 Looper 。 quitSafely() 是把已有的消息处理完之后才安全退出。 4. Handlerhandler 的工作主要是发送和接收消息的过程 发送消息是通过一系列的 send 和 post 方法来发送的，而 post 的一系列方法最终还是通过 send 实现的，发送一条消息的过程如下： 123456789101112131415161718192021222324252627282930313233public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 从上边可以发现，Handler 发送消息，实际上只是在消息队列中插入了一条消息。 MessageQueue 的 next 方法会将这条消息返回给 Looper ，最终这条消息由 Looper 交给 Handler 的 dispatchMessage 方法处理，如下所示： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 最后，调用 Handler 的 handlerMessage 方法来处理消息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android6.0运行时权限插件版]]></title>
      <url>%2F2017%2F03%2F23%2Fandroid6-0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%8F%92%E4%BB%B6%E7%89%88%2F</url>
      <content type="text"><![CDATA[前言：介绍运行时权限的第三方库 PermissionsDispatcher 配合 AndroidStudio 的使用 PermissionsDispatcher 库地址： PermissionsDispatcher 本文来源： https://github.com/alidili/PermissionDemo 正文：PermissionsDispatcher 通过注解的方式，动态生成类处理运行时权限。配合插件使用，可自动生成代码。 使用： 1. 在 AndroidStudio中搜索插件 PermissionsDispatcher ，并下载安装2. 将下面这段代码添加到 project 的 build.gradle 文件中：12345buildscript &#123; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125;&#125; 3. 将下面的代码添加到app module的build.gradle文件中，目前最新版本为 2.3.2 ,不过参考的文章用的 2.1.3，我也就没改123456apply plugin: &apos;android-apt&apos;dependencies &#123; compile &apos;com.github.hotchemi:permissionsdispatcher:2.1.3&apos; apt &apos;com.github.hotchemi:permissionsdispatcher-processor:2.1.3&apos;&#125; 4. 准备工作已经完成了，下面来进行代码的生成，在 Android Studio 中选择 Code — Generate — Generate Runtime Permissions，也可以快捷键 Alt + Insert ，选择 Generate Runtime Permissions ，如下图所示： 其中： 1234567@NeedsPermission 当申请的权限被用户允许后，调用此方法。@OnShowRationale 当第一次申请权限时，用户选择拒绝，再次申请时调用此方法， 在此方法中提示用户为什么需要这个权限。@OnPermissionDenied 当申请的权限被用户拒绝后，调用此方法x`@OnNeverAskAgain 当用户点击不再询问后，调用此方法。 5. 代码大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.yang.permissiondemo;import android.Manifest;import android.annotation.TargetApi;import android.content.DialogInterface;import android.graphics.Color;import android.os.Build;import android.os.Bundle;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.widget.TextView;import android.widget.Toast;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;import permissions.dispatcher.NeedsPermission;import permissions.dispatcher.OnNeverAskAgain;import permissions.dispatcher.OnPermissionDenied;import permissions.dispatcher.OnShowRationale;import permissions.dispatcher.PermissionRequest;import permissions.dispatcher.RuntimePermissions;@RuntimePermissionspublic class PermissionsDispatcherActivity extends AppCompatActivity &#123; @Bind(R.id.tv_permission_status) TextView tvPermissionStatus; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_request_permission) public void onClick() &#123; requestPermission(); &#125; @TargetApi(Build.VERSION_CODES.M) private void requestPermission() &#123; //申请权限 PermissionsDispatcherActivityPermissionsDispatcher.openCameraWithCheck(this); &#125; @NeedsPermission(Manifest.permission.CAMERA) void openCamera() &#123; tvPermissionStatus.setTextColor(Color.GREEN); tvPermissionStatus.setText(&quot;相机权限已申请&quot;); &#125; @OnShowRationale(Manifest.permission.CAMERA) void showRationale(final PermissionRequest request) &#123; new AlertDialog.Builder(this) .setMessage(&quot;申请相机权限&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //再次执行请求 request.proceed(); &#125; &#125;) .show(); &#125; @OnPermissionDenied(Manifest.permission.CAMERA) void permissionDenied() &#123; Toast.makeText(this, &quot;权限被拒绝&quot;, Toast.LENGTH_SHORT).show(); &#125; @OnNeverAskAgain(Manifest.permission.CAMERA) void neverAskAgain() &#123; Toast.makeText(this, &quot;不再询问&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionsDispatcherActivityPermissionsDispatcher.onRequestPermissionsResult(this, requestCode, grantResults); &#125;&#125; 注： PermissionsDispatcherActivityPermissionsDispatcher 这个类本来是没有的需要先编译一次才会出现，点击 Build - Make Project。 6. 兼容性，为了保持兼容性建议使用v4包的兼容方法：1234ContextCompat.checkSelfPermission() ActivityCompat.requestPermissions()ActivityCompat.OnRequestPermissionsResultCallback()ActivityCompat.shouldShowRequestPermissionRationale()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android6.0运行时权限使用流程]]></title>
      <url>%2F2017%2F03%2F23%2Fandroid6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前言：本文不涉及第三方的类库和工具，只是原生的操作流程 一、简介Android6.0 之前，用户安装 app ,会根据声明的权限生成一个权限列表，只有用户同意才能完成安装，而用户一般也不会注意这些权限，有可能会造成一些私密权限的泄漏，从而威胁到我们手机本身的信息安全！ Android6.0之后，运行时权限解决了这一问题，用户可以直接安装 app ，一些高危权限会在应用运行的过程中动态申请，我们可以选择同意或者拒绝，也可以在设置界面对每个 app 的权限进行查看和修改。 二、权限简介官网上有句话，系统权限分为几个保护级别，需要了解的最重要的两个是 正常权限 和 危险权限 ，而运行时权限就是针对危险权限而言的。 危险权限官网定义： 危险权限涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，则用户必须明确向应用授予该权限。 危险权限种类： 注意：左侧为权限组，右侧为权限组的具体权限，同一组内的任何一个权限被授权了，其他权限也自动被授权，系统只告诉用户应用需要的权限组，而不告知具体权限！ 使用流程 需要将 app 的 targetSdkVersion 设置到 23 及其以上，这样才有可能触发运行时权限。 在AndroidManifest文件中添加所需要的权限。 先检查系统版本，如果系统在 6.0 以上，采取运行时权限，版本名称和版本号参考官网：https://developer.android.com/reference/android/os/Build.VERSION_CODES.html 1Build.VERSION.SDK_INT &gt;= 23 几个重要的 API 12345678910 检查某个权限是否被授予 ，以相机权限为例if ( ContextCompat.checkSelfPermission ( this,Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED ) &#123; //申请相机权限操作&#125;else&#123; //相机权限已申请操作&#125; 123456789该方法只有在用户在上一次已经拒绝过你的这个权限申请。也就是说，用户已经拒绝一次了，你又弹个授权框，你需要给用户一个解释，为什么要授权，则使用该方法，只有第一次被拒绝，当第二次申请时， if 条件为 true，其他都为 falseif (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; &#125; 12345678910申请相机权限操作第一个参数是Context；第二个参数是需要申请的权限的字符串数组；第三个参数为requestCode， 主要用于回调时候监测其中第二个参数支持一次性申请多个权限的，系统会通过对话框逐一询问用户是否授权ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, CAMERA_REQUEST_CODE); 123456789101112131415161718192021此方法是权限申请的回调方法，在此方法中处理权限申请成功或失败后的操作。@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case CAMERA_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限申请成功操作 &#125; else &#123; //权限申请失败 //用户勾选了禁止后不再询问，提示用户手动打开权限 &#125; return; &#125; &#125;&#125; 完整的操作流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//判断系统版本是否大于23 private boolean isRequestPermission() &#123; return Build.VERSION.SDK_INT &gt;= 23; &#125; //自定义请求权限 private void requestPermission() &#123; if (!isRequestPermission()) &#123; return; &#125; //检查是否已经拥有该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123; //判断是否是第二次申请，（第一次被用户拒绝），如果是的话，做一些说明，一般是弹框说明 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; //弹出一个dialog，说明第二次请求原因 new AlertDialog.Builder(this) .setMessage(&quot;申请照相机权限&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, CAMERA_REQUEST_CODE ); &#125; &#125;).show(); &#125; else &#123;//不是的话就执行申请操作 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;&#125;, CAMERA_REQUEST_CODE ); &#125; &#125; else &#123; //相机权限已申请操作 &#125; &#125; /** * 权限申请回调 * * @param requestCode 请求码 * @param permissions 请求的权限列表 * @param grantResults 请求的结果列表 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case CAMERA_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限申请成功操作 &#125; else &#123; //权限申请失败 //用户勾选了禁止后不再询问，提示用户手动打开权限 if (!ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.CAMERA))&#123; Toast.makeText(MainActivity.this,&quot;请在设置列表打开相机权限&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; return; &#125; &#125; &#125; 有几位大神总结的很不错，附上链接 Hongyang大神 郭霖大神]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔感受]]></title>
      <url>%2F2017%2F03%2F22%2F%E9%9A%8F%E7%AC%94%E6%84%9F%E5%8F%97%2F</url>
      <content type="text"><![CDATA[前言生活中从不缺少感悟和体会，我要把这些感想记录下来，以后再看或许是些宝贵的经验！ 1. 结缘小密圈结缘小密圈说起来也很凑巧，也很幸运，自己的微信有很多技术性的公众号，关注的原因无非就是为了多学点东西，其中有一个叫做 「AndroidDevelop」 ，是看过他的一篇博客然后搜索添加的，这个公众号的主人叫做 「stormzhang」 ，人称 帅比张，一直在看他写的文章，也觉得不错，然后有一天看到此人开通小密圈了，然后果断下载付费入圈 —– 「帅比张读者圈」，时间是 2月27号 ，现在想来，挺幸运的，要不我得错过多少好东西，入圈没几天就感觉值回票价了！！ 注：此博客就是在加入小密圈之后才了解并搭建的！ 2. 写作动力我不是一个喜欢写东西的人，现在才了解到原因，是因为我还没了解到写作的好处！写作不仅能提高逼格，更重要的是，让我学会梳理和记录平时所学，从而提高学习和解决问题的效率，记录自己，帮助他人！ 有些东西，脑子里边知道，能说出来，不一定能写的出来 3. 写作排版说实话，之前就算写东西也从来没注意过这些东西，当初写的目的仅仅是为了记录一些东西，由于写的比较乱和杂，也导致很多东西时间长就丢了，帅比张分享了一些关于排版的规格，按照规格一来，确实好看了不少，当然我现在还是初学者，有待改进！ 4.独立思考和选择当遇到两难抉择的问题时，只需要把所有的选择罗列出来，利弊各自写下来，这样就一目了然了！ 5. 付费买知识付费买知识是我个人意识的重大改变，谁的时间都不是免费的，你占用别人的时间来为你回答问题，难道不应该掏钱么？ 可能书买了不会去看，但是如果让你付费问别人问题，你会么？，如果会的话，我想这个问题的答案肯定会记得牢一点！ 我感觉这跟我们找人办事请吃饭差不多，只不过换了个的场景！ 6.只字不差的阅读我认为阅读越细越好，特别是一些技术文章，细致的阅读能让人深入进去，从而提炼更为有用的东西，这也是我要提高的地方！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git命令总结]]></title>
      <url>%2F2017%2F03%2F21%2FGit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言：由于在搞博客的原因，顺带着多了解了点 Git 命令，欢迎大家指正！ 一、Git工具下载地址：https://git-scm.com/download/安装也很简单，基本就是一直下一步，选默认的就好！ 二、常用命令介绍1. 本地文件夹与 github 远程仓库建立连接在需要建立连接的文件夹，右键 Git Bash 输入： 12git initgit remote add origin &lt;server&gt; 其中，server是 github 远程仓库地址，origin只是仓库的一个别名，这里可以随意变！ 2. 将本地的文件，同步到 github 远程仓库上123git add . #添加所有目录，后边有个点git commit -m &quot;message&quot; #添加提交说明信息git push -u origin master #云端同步 3. 把 github 上的文件取回本地在本地先建立一个文件夹，右键 Git Bash 输入： 1234git initgit remote add origin &lt;server&gt; # server是远程仓库地址git fetch –allgit merge origin/master #这个origin与步骤 1 的那个一致 4. 如果两个PC端操作一个远程仓库地址12每次先 git pull 进行同步更新，然后执行步骤 2 5.修改 github 远程仓库地址 第一种方式：在需要修改远程地址的文件夹下 右键 Git Bash 输入： 12git remote rm origin #先删除git remote add origin &lt;server&gt; #重新添加地址 第二种方式：找到.git文件夹下的config文件 找到 [remote “origin”]，下边的url就是远程仓库地址，修改成自己需要的就好！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Hexo-Github---搭建个人博客笔记]]></title>
      <url>%2F2017%2F03%2F19%2F%E5%9F%BA%E4%BA%8EHexo-Github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0-1%2F</url>
      <content type="text"><![CDATA[前言:为了搭建这个博客，踩得坑不计其数，说焦头烂额也不为过．参考博客： 基于Hexo+GitHub Pages 搭建个人博客教程 正文：一、环境的搭建 Note.js下载和安装 1.下载地址：https://nodejs.org/en/download/ 2.windows下安装非常简单 参考地址：http://www.runoob.com/nodejs/nodejs-install-setup.html Git下载和安装 1.下载地址：https://git-scm.com/download/ 2.windows下安装也很简单，参考地址：http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html 二、安装Hexo 桌面上鼠标右键打开Git Bash。 输入安装命令 1npm install -g hexo-cli 选择硬盘目录作为存放文件的路径 1hexo init e:\blog #在E盘先创建一个blog文件夹存放文件 进入该目录后再进行其他操作 1cd e:\blog 执行安装依赖包的命令 1npm install 生成部署文件，启动本地服务 123hexo g # 或者hexo generate hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 现在我们打开 http://localhost:4000/ 就可以看到我们刚才搭建的本地博客了，Hexo会默认生成一个Hello World的博文。 停止是ctrl+c hexo几个常用命令123456hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署博客到远端服务器hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 三、github Pages设置 登录github官网创建github账号： http://www.github.com/ 创建仓库: 点击右侧+号，new repository 仓库名字必须是 username/username.github.io ，这是特殊的命名约定。 username 就是注册的github账号名字 配置 ssh 检查本地是否存在 ssh ，如果存在就删除 .ssh文件夹 1ls -al ~/.ssh 设置 name 和 email ，注意：这里的那么和email是随意的，并没有特别的限定 12git config --global user.name &quot;&lt;your name&gt;&quot;git config --global user.email &quot;&lt;your email&gt;&quot; 生成 ssh 秘钥 ，这里的邮箱是注册 github 的邮箱 1ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot; 一路回车，可以设置密码，如果设置要记住后边要用 这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub 打开 id_rsa.pub 复制全部内容，这就是 ssh 秘钥 配置 ssh 秘钥 在自己的 github 主页，点击右侧头像下的 setting ，选择 SSH and GPG keys , 然后点击 New SSH key，粘贴刚才复制的 SSH 保存。 检查是否配置成功 ，输入以下命令 1ssh git@github.com 成功的话会显示以下内容 1234567The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 四、部署到 github 配置 _config.yml ，在自己创建的 blog 目录下 ，最下方。 1234567# Deployment## Docs: https://hexo.io/docs/deployment.html# ssh://git@github.com/git-xuhao/git-xuhao.github.iodeploy: type: git repo: ssh://git@github.com/git-xuhao/git-xuhao.github.io branch: master 其中，repo是我们刚刚建立的远程仓库，换成你自己的仓库，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误 安装 git 包 1npm install hexo-deployer-git --save 部署到 github 上 1hexo deploy 现在我们可以通过访问 http://adsuper.github.io/ 来访问我们自己的博客啦，其中链接是自己的仓库名。 五、Hexo 配置文件常用到的配置文件一共有两个，分别是blog根目录下的 _config.yml 和 主题下的 _config.yml ，(themes文件夹的为主题)； 关于配置文件的具体描述请参考： https://hexo.io/zh-cn/docs/configuration.html 六、如何使用？ 新建一篇博文可通过以下的命令 ，要在bolg根目录下打开 Git Bash 1hexo new &quot;name&quot; 其中name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件 博文写好之后，在每次发布之前，我们要先将写好的博客生成静态文件，执行以下命令 1hexo g 静态文件生成之后，便可以部署到GitHub上 hexo d 然后打开我们的博客，就可以看到我们刚刚新建的博文了 七、主题推荐Hexo提供了许多的主题可供我们选择和使用，在./themes目录下存放主题。刚才默认生成的博客用的就是默认的主题landscape。 主题推荐请参考： https://github.com/hexojs/hexo/wiki/Themes 我自己使用的是 Next 主题。 Next主题的配置方法参考： http://theme-next.iissnan.com/getting-started.html]]></content>
    </entry>

    
  
  
</search>
