<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android中的消息机制--Handler]]></title>
      <url>%2F2017%2F03%2F24%2FAndroid%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler%2F</url>
      <content type="text"><![CDATA[前言网上关于Handler机制运行原理的文章已经很多，但毕竟不是自己的，也不一定适合自己的阅读习惯！ 一、概述 Android 的消息机制主要是指 Handler 的运行机制， Handler 的运行需要底层的 MessageQueue 和 Looper 支撑，这三者实际上是一个整体 ( 配套使用 ) ，只不过我们在开发过程中比较多的接触到 Handler 而已。 说到 Handler ，很多人都知道是为了更新 UI ，这不错，但这只是 Handler 的一个应用场景而已。 Handler 出现的原因，我想是因为不能在主线程中做耗时操作，一旦耗时操作超过 5s 就会出现 ANR 异常，下面代码是 Handler 的最常用用法: 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; private Handler myHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //主线程中处理发送过来的message &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //子线程中发送Handler消息 new Thread()&#123; @Override public void run() &#123; Message msg = new Message(); msg.what = 1; myHandler.sendMessage(msg); &#125; &#125;.start(); &#125; &#125;&#125; 注意： 线程中默认是没有 Looper的，如果想要使用 Handler 就必须为线程创建 Looper ，否则会报错，Looper 是运行在 Handler 所在的线程中的。 主线程比较特殊，它在创建的时候就会初始化 Looper，会调用 Looper.prepaerMainLooper() 来创建主线程的 looper 以及 MessageQueue ，也就是说，在主线程中默认可以使用 Handler 。 大致的原理： Handler 通过 send 或 post 的 一系列方法发送 message 到 MessageQueue 。 MessageQueue 翻译过来叫做消息队列，内部存储 Handler 发送过来的一系列消息，仅仅能存储消息，数据存储结构为单链表。 Looper 会以无限循环的方式从 MessageQueue 中查找是否有新消息，如果有就处理消息，否则就一直等待着。 二、详细分析主要介绍下 ThreadLocal 、 Handler 、 MessageQueue 、Looper 1. ThreadLocalThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只能在指定线程中才可以获取到存储的数据。 介绍 ThreadLocal 是因为不同线程的 Handler 获取对应 Looper 采用的就是这个原理。 举个例子： 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; //ThreadLocal 对象，存储的是 boolean 值 private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBooleanThreadLocal.set(true); Log.i(&quot;Thread---Main:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); new Thread(&quot;Thread---1&quot;)&#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.i(&quot;Thread---1:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); &#125; &#125;.start(); new Thread(&quot;Thread---2&quot;)&#123; @Override public void run() &#123; Log.i(&quot;Thread---2:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); &#125; &#125;.start(); &#125; 代码中，在主线程中设置 mBooleanThreadLocal 为 true ，在 Thread—1 中设置 mBooleanThreadLocal 为 false ，在 Thread—2 中没有设置， mBooleanThreadLocal 通过 set() 和 get() 方法进行数据的设置和取出操作。 打印出来的结果为： 12312945-12945/? I/Thread---Main:: true12945-12959/? I/Thread---1:: false12945-12960/? I/Thread---2:: null 2. MessageQueue翻译过来为消息队列，其主要包含两个操作：插入和读取，分别对应 MessageQueue 的两个方法 enqueueMessage() 和 next() ，另外，读取过的消息会删除掉！ 3. LooperLooper 会不停的从 MessageQueue 中查看是否有新消息，有就立刻处理，否则就一直阻塞，在 Looper 的构造方法中会创建一个 MessageQueue 对象，再次印证了那四个字—配套使用。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 除了主线程之外，在其他线程中如何创建 Looper 对象，如下所示： 1234567891011121314new Thread(&quot;Thread---1&quot;)&#123; @Override public void run() &#123; //创建 Looper 对象 Looper.prepare(); Message msg = new Message(); msg.what = 1; myHandler.sendMessage(msg); //开启消息循环 Looper.loop(); &#125; &#125;.start(); 获取主线程 Looper， 通过方法：Looper.getMainLooper(); Looper 退出，有两个方法，Looper 的 quit() 和 quitSafely() ，其内部还是让 MessageQueue 的 next 方法返回 null ， next 方法返回 null 是唯一的退出方式 ，建议不需要的时候终止 Looper。 quit() 是直接退出 Looper 。 quitSafely() 是把已有的消息处理完之后才安全退出。 4. Handlerhandler 的工作主要是发送和接收消息的过程 发送消息是通过一系列的 send 和 post 方法来发送的，而 post 的一系列方法最终还是通过 send 实现的，发送一条消息的过程如下： 123456789101112131415161718192021222324252627282930313233public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 从上边可以发现，Handler 发送消息，实际上只是在消息队列中插入了一条消息。 MessageQueue 的 next 方法会将这条消息返回给 Looper ，最终这条消息由 Looper 交给 Handler 的 dispatchMessage 方法处理，如下所示： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 最后，调用 Handler 的 handlerMessage 方法来处理消息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android6.0运行时权限插件版]]></title>
      <url>%2F2017%2F03%2F23%2Fandroid6-0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%8F%92%E4%BB%B6%E7%89%88%2F</url>
      <content type="text"><![CDATA[前言：介绍运行时权限的第三方库 PermissionsDispatcher 配合 AndroidStudio 的使用 PermissionsDispatcher 库地址： PermissionsDispatcher 本文来源： https://github.com/alidili/PermissionDemo 正文：PermissionsDispatcher 通过注解的方式，动态生成类处理运行时权限。配合插件使用，可自动生成代码。 使用： 1. 在 AndroidStudio中搜索插件 PermissionsDispatcher ，并下载安装2. 将下面这段代码添加到 project 的 build.gradle 文件中：12345buildscript &#123; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125;&#125; 3. 将下面的代码添加到app module的build.gradle文件中，目前最新版本为 2.3.2 ,不过参考的文章用的 2.1.3，我也就没改123456apply plugin: &apos;android-apt&apos;dependencies &#123; compile &apos;com.github.hotchemi:permissionsdispatcher:2.1.3&apos; apt &apos;com.github.hotchemi:permissionsdispatcher-processor:2.1.3&apos;&#125; 4. 准备工作已经完成了，下面来进行代码的生成，在 Android Studio 中选择 Code — Generate — Generate Runtime Permissions，也可以快捷键 Alt + Insert ，选择 Generate Runtime Permissions ，如下图所示： 其中： 1234567@NeedsPermission 当申请的权限被用户允许后，调用此方法。@OnShowRationale 当第一次申请权限时，用户选择拒绝，再次申请时调用此方法， 在此方法中提示用户为什么需要这个权限。@OnPermissionDenied 当申请的权限被用户拒绝后，调用此方法x`@OnNeverAskAgain 当用户点击不再询问后，调用此方法。 5. 代码大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.yang.permissiondemo;import android.Manifest;import android.annotation.TargetApi;import android.content.DialogInterface;import android.graphics.Color;import android.os.Build;import android.os.Bundle;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.widget.TextView;import android.widget.Toast;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;import permissions.dispatcher.NeedsPermission;import permissions.dispatcher.OnNeverAskAgain;import permissions.dispatcher.OnPermissionDenied;import permissions.dispatcher.OnShowRationale;import permissions.dispatcher.PermissionRequest;import permissions.dispatcher.RuntimePermissions;@RuntimePermissionspublic class PermissionsDispatcherActivity extends AppCompatActivity &#123; @Bind(R.id.tv_permission_status) TextView tvPermissionStatus; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_request_permission) public void onClick() &#123; requestPermission(); &#125; @TargetApi(Build.VERSION_CODES.M) private void requestPermission() &#123; //申请权限 PermissionsDispatcherActivityPermissionsDispatcher.openCameraWithCheck(this); &#125; @NeedsPermission(Manifest.permission.CAMERA) void openCamera() &#123; tvPermissionStatus.setTextColor(Color.GREEN); tvPermissionStatus.setText(&quot;相机权限已申请&quot;); &#125; @OnShowRationale(Manifest.permission.CAMERA) void showRationale(final PermissionRequest request) &#123; new AlertDialog.Builder(this) .setMessage(&quot;申请相机权限&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //再次执行请求 request.proceed(); &#125; &#125;) .show(); &#125; @OnPermissionDenied(Manifest.permission.CAMERA) void permissionDenied() &#123; Toast.makeText(this, &quot;权限被拒绝&quot;, Toast.LENGTH_SHORT).show(); &#125; @OnNeverAskAgain(Manifest.permission.CAMERA) void neverAskAgain() &#123; Toast.makeText(this, &quot;不再询问&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionsDispatcherActivityPermissionsDispatcher.onRequestPermissionsResult(this, requestCode, grantResults); &#125;&#125; 注： PermissionsDispatcherActivityPermissionsDispatcher 这个类本来是没有的需要先编译一次才会出现，点击 Build - Make Project。 6. 兼容性，为了保持兼容性建议使用v4包的兼容方法：1234ContextCompat.checkSelfPermission() ActivityCompat.requestPermissions()ActivityCompat.OnRequestPermissionsResultCallback()ActivityCompat.shouldShowRequestPermissionRationale()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android6.0运行时权限使用流程]]></title>
      <url>%2F2017%2F03%2F23%2Fandroid6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前言：本文不涉及第三方的类库和工具，只是原生的操作流程 一、简介Android6.0 之前，用户安装 app ,会根据声明的权限生成一个权限列表，只有用户同意才能完成安装，而用户一般也不会注意这些权限，有可能会造成一些私密权限的泄漏，从而威胁到我们手机本身的信息安全！ Android6.0之后，运行时权限解决了这一问题，用户可以直接安装 app ，一些高危权限会在应用运行的过程中动态申请，我们可以选择同意或者拒绝，也可以在设置界面对每个 app 的权限进行查看和修改。 二、权限简介官网上有句话，系统权限分为几个保护级别，需要了解的最重要的两个是 正常权限 和 危险权限 ，而运行时权限就是针对危险权限而言的。 危险权限官网定义： 危险权限涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，则用户必须明确向应用授予该权限。 危险权限种类： 注意：左侧为权限组，右侧为权限组的具体权限，同一组内的任何一个权限被授权了，其他权限也自动被授权，系统只告诉用户应用需要的权限组，而不告知具体权限！ 使用流程 需要将 app 的 targetSdkVersion 设置到 23 及其以上，这样才有可能触发运行时权限。 在AndroidManifest文件中添加所需要的权限。 先检查系统版本，如果系统在 6.0 以上，采取运行时权限，版本名称和版本号参考官网：https://developer.android.com/reference/android/os/Build.VERSION_CODES.html 1Build.VERSION.SDK_INT &gt;= 23 几个重要的 API 12345678910 检查某个权限是否被授予 ，以相机权限为例if ( ContextCompat.checkSelfPermission ( this,Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED ) &#123; //申请相机权限操作&#125;else&#123; //相机权限已申请操作&#125; 123456789该方法只有在用户在上一次已经拒绝过你的这个权限申请。也就是说，用户已经拒绝一次了，你又弹个授权框，你需要给用户一个解释，为什么要授权，则使用该方法，只有第一次被拒绝，当第二次申请时， if 条件为 true，其他都为 falseif (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; &#125; 12345678910申请相机权限操作第一个参数是Context；第二个参数是需要申请的权限的字符串数组；第三个参数为requestCode， 主要用于回调时候监测其中第二个参数支持一次性申请多个权限的，系统会通过对话框逐一询问用户是否授权ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, CAMERA_REQUEST_CODE); 123456789101112131415161718192021此方法是权限申请的回调方法，在此方法中处理权限申请成功或失败后的操作。@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case CAMERA_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限申请成功操作 &#125; else &#123; //权限申请失败 //用户勾选了禁止后不再询问，提示用户手动打开权限 &#125; return; &#125; &#125;&#125; 完整的操作流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//判断系统版本是否大于23 private boolean isRequestPermission() &#123; return Build.VERSION.SDK_INT &gt;= 23; &#125; //自定义请求权限 private void requestPermission() &#123; if (!isRequestPermission()) &#123; return; &#125; //检查是否已经拥有该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123; //判断是否是第二次申请，（第一次被用户拒绝），如果是的话，做一些说明，一般是弹框说明 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; //弹出一个dialog，说明第二次请求原因 new AlertDialog.Builder(this) .setMessage(&quot;申请照相机权限&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, CAMERA_REQUEST_CODE ); &#125; &#125;).show(); &#125; else &#123;//不是的话就执行申请操作 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;&#125;, CAMERA_REQUEST_CODE ); &#125; &#125; else &#123; //相机权限已申请操作 &#125; &#125; /** * 权限申请回调 * * @param requestCode 请求码 * @param permissions 请求的权限列表 * @param grantResults 请求的结果列表 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case CAMERA_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限申请成功操作 &#125; else &#123; //权限申请失败 //用户勾选了禁止后不再询问，提示用户手动打开权限 if (!ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.CAMERA))&#123; Toast.makeText(MainActivity.this,&quot;请在设置列表打开相机权限&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; return; &#125; &#125; &#125; 有几位大神总结的很不错，附上链接 Hongyang大神 郭霖大神]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔感受]]></title>
      <url>%2F2017%2F03%2F22%2F%E9%9A%8F%E7%AC%94%E6%84%9F%E5%8F%97%2F</url>
      <content type="text"><![CDATA[前言生活中从不缺少感悟和体会，我要把这些感想记录下来，以后再看或许是些宝贵的经验！ 1. 结缘小密圈结缘小密圈说起来也很凑巧，也很幸运，自己的微信有很多技术性的公众号，关注的原因无非就是为了多学点东西，其中有一个叫做 「AndroidDevelop」 ，是看过他的一篇博客然后搜索添加的，这个公众号的主人叫做 「stormzhang」 ，人称 帅比张，一直在看他写的文章，也觉得不错，然后有一天看到此人开通小密圈了，然后果断下载付费入圈 —– 「帅比张读者圈」，时间是 2月27号 ，现在想来，挺幸运的，要不我得错过多少好东西，入圈没几天就感觉值回票价了！！ 注：此博客就是在加入小密圈之后才了解并搭建的！ 2. 写作动力我不是一个喜欢写东西的人，现在才了解到原因，是因为我还没了解到写作的好处！写作不仅能提高逼格，更重要的是，让我学会梳理和记录平时所学，从而提高学习和解决问题的效率，记录自己，帮助他人！ 有些东西，脑子里边知道，能说出来，不一定能写的出来 3. 写作排版说实话，之前就算写东西也从来没注意过这些东西，当初写的目的仅仅是为了记录一些东西，由于写的比较乱和杂，也导致很多东西时间长就丢了，帅比张分享了一些关于排版的规格，按照规格一来，确实好看了不少，当然我现在还是初学者，有待改进！ 4.独立思考和选择当遇到两难抉择的问题时，只需要把所有的选择罗列出来，利弊各自写下来，这样就一目了然了！ 5. 付费买知识付费买知识是我个人意识的重大改变，谁的时间都不是免费的，你占用别人的时间来为你回答问题，难道不应该掏钱么？ 可能书买了不会去看，但是如果让你付费问别人问题，你会么？，如果会的话，我想这个问题的答案肯定会记得牢一点！ 我感觉这跟我们找人办事请吃饭差不多，只不过换了个的场景！ 6.只字不差的阅读我认为阅读越细越好，特别是一些技术文章，细致的阅读能让人深入进去，从而提炼更为有用的东西，这也是我要提高的地方！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git命令总结]]></title>
      <url>%2F2017%2F03%2F21%2FGit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言：由于在搞博客的原因，顺带着多了解了点 Git 命令，欢迎大家指正！ 一、Git工具下载地址：https://git-scm.com/download/安装也很简单，基本就是一直下一步，选默认的就好！ 二、常用命令介绍1. 本地文件夹与 github 远程仓库建立连接在需要建立连接的文件夹，右键 Git Bash 输入： 12git initgit remote add origin &lt;server&gt; 其中，server是 github 远程仓库地址，origin只是仓库的一个别名，这里可以随意变！ 2. 将本地的文件，同步到 github 远程仓库上123git add . #添加所有目录，后边有个点git commit -m &quot;message&quot; #添加提交说明信息git push -u origin master #云端同步 3. 把 github 上的文件取回本地在本地先建立一个文件夹，右键 Git Bash 输入： 1234git initgit remote add origin &lt;server&gt; # server是远程仓库地址git fetch –allgit merge origin/master #这个origin与步骤 1 的那个一致 4. 如果两个PC端操作一个远程仓库地址12每次先 git pull 进行同步更新，然后执行步骤 2 5.修改 github 远程仓库地址 第一种方式：在需要修改远程地址的文件夹下 右键 Git Bash 输入： 12git remote rm origin #先删除git remote add origin &lt;server&gt; #重新添加地址 第二种方式：找到.git文件夹下的config文件 找到 [remote “origin”]，下边的url就是远程仓库地址，修改成自己需要的就好！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Hexo-Github---搭建个人博客笔记]]></title>
      <url>%2F2017%2F03%2F19%2F%E5%9F%BA%E4%BA%8EHexo-Github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0-1%2F</url>
      <content type="text"><![CDATA[前言:为了搭建这个博客，踩得坑不计其数，说焦头烂额也不为过．参考博客： 基于Hexo+GitHub Pages 搭建个人博客教程 正文：一、环境的搭建 Note.js下载和安装 1.下载地址：https://nodejs.org/en/download/ 2.windows下安装非常简单 参考地址：http://www.runoob.com/nodejs/nodejs-install-setup.html Git下载和安装 1.下载地址：https://git-scm.com/download/ 2.windows下安装也很简单，参考地址：http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html 二、安装Hexo 桌面上鼠标右键打开Git Bash。 输入安装命令 1npm install -g hexo-cli 选择硬盘目录作为存放文件的路径 1hexo init e:\blog #在E盘先创建一个blog文件夹存放文件 进入该目录后再进行其他操作 1cd e:\blog 执行安装依赖包的命令 1npm install 生成部署文件，启动本地服务 123hexo g # 或者hexo generate hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 现在我们打开 http://localhost:4000/ 就可以看到我们刚才搭建的本地博客了，Hexo会默认生成一个Hello World的博文。 停止是ctrl+c hexo几个常用命令123456hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署博客到远端服务器hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 三、github Pages设置 登录github官网创建github账号： http://www.github.com/ 创建仓库: 点击右侧+号，new repository 仓库名字必须是 username/username.github.io ，这是特殊的命名约定。 username 就是注册的github账号名字 配置 ssh 检查本地是否存在 ssh ，如果存在就删除 .ssh文件夹 1ls -al ~/.ssh 设置 name 和 email ，注意：这里的那么和email是随意的，并没有特别的限定 12git config --global user.name &quot;&lt;your name&gt;&quot;git config --global user.email &quot;&lt;your email&gt;&quot; 生成 ssh 秘钥 ，这里的邮箱是注册 github 的邮箱 1ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot; 一路回车，可以设置密码，如果设置要记住后边要用 这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub 打开 id_rsa.pub 复制全部内容，这就是 ssh 秘钥 配置 ssh 秘钥 在自己的 github 主页，点击右侧头像下的 setting ，选择 SSH and GPG keys , 然后点击 New SSH key，粘贴刚才复制的 SSH 保存。 检查是否配置成功 ，输入以下命令 1ssh git@github.com 成功的话会显示以下内容 1234567The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 四、部署到 github 配置 _config.yml ，在自己创建的 blog 目录下 ，最下方。 1234567# Deployment## Docs: https://hexo.io/docs/deployment.html# ssh://git@github.com/git-xuhao/git-xuhao.github.iodeploy: type: git repo: ssh://git@github.com/git-xuhao/git-xuhao.github.io branch: master 其中，repo是我们刚刚建立的远程仓库，换成你自己的仓库，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误 安装 git 包 1npm install hexo-deployer-git --save 部署到 github 上 1hexo deploy 现在我们可以通过访问 http://adsuper.github.io/ 来访问我们自己的博客啦，其中链接是自己的仓库名。 五、Hexo 配置文件常用到的配置文件一共有两个，分别是blog根目录下的 _config.yml 和 主题下的 _config.yml ，(themes文件夹的为主题)； 关于配置文件的具体描述请参考： https://hexo.io/zh-cn/docs/configuration.html 六、如何使用？ 新建一篇博文可通过以下的命令 ，要在bolg根目录下打开 Git Bash 1hexo new &quot;name&quot; 其中name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件 博文写好之后，在每次发布之前，我们要先将写好的博客生成静态文件，执行以下命令 1hexo g 静态文件生成之后，便可以部署到GitHub上 hexo d 然后打开我们的博客，就可以看到我们刚刚新建的博文了 七、主题推荐Hexo提供了许多的主题可供我们选择和使用，在./themes目录下存放主题。刚才默认生成的博客用的就是默认的主题landscape。 主题推荐请参考： https://github.com/hexojs/hexo/wiki/Themes 我自己使用的是 Next 主题。 Next主题的配置方法参考： http://theme-next.iissnan.com/getting-started.html]]></content>
    </entry>

    
  
  
</search>
