<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[drawable 和 mipmap 不得不说的故事]]></title>
      <url>%2F2017%2F04%2F13%2Fdrawable%E5%92%8Cmipmap%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[一、图片到底存到哪个目录下 Google 官方推荐，mipmap 文件夹下仅仅存放应用启动图标 其他的 png 图片和 .9.png 等图片还是存放在相应的 drawable 目录 二、如何自动创建响应的 drawable 目录AndroidStudio 项目默认只有一个 drawable 目录，而没有对应的 -hdpi 等目录，解决方式如下： 需要修改 androidStudio 的默认配置文件 定位到 androidStudio 的安装目录：C:\Program Files\Android\Android Studio\plugins\android\lib\templates\gradle-projects\NewAndroidModule 修改该文件夹下的 recipe.xml.ftl 文件 大概在 28 行的原文件一部分为： 123456789101112131415&lt;#if !(isInstantApp!false) || (isBaseAtom!false)&gt; &lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable&quot; /&gt; &lt;#if copyIcons &amp;&amp; !isLibraryProject&gt; &lt;#if buildApi gte 25 &amp;&amp; targetApi gte 25&gt; &lt;copy from=&quot;root/res/mipmap-hdpi/&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-hdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-mdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-mdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-xhdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-xhdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-xxhdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-xxhdpi/&quot; /&gt; &lt;copy from=&quot;root/res/mipmap-xxxhdpi&quot; to=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/mipmap-xxxhdpi/&quot; /&gt; &lt;#else&gt; 在 &lt;mkdir 这一行之后添加如下代码： 1234&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-hdpi&quot; /&gt;&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-mdpi&quot; /&gt;&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-xhdpi&quot; /&gt;&lt;mkdir at=&quot;$&#123;escapeXmlAttribute(resOut)&#125;/drawable-xxhdpi&quot; /&gt; 重启 androidStudio ，然后新建项目，就会发现已经有对应的 drawable 目录了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中的单例模式总结]]></title>
      <url>%2F2017%2F04%2F13%2FAndroid%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%98%2F</url>
      <content type="text"><![CDATA[前言：简单来说，设计模式就是前人留下的一些经验的总结，把这些总结分类为不同的设计模式，通过使用这些模式，使我们的代码看起来更加简洁，复用性更高，可维护性更高，是 Android 进阶之路必不可少的一环！ 正文：单例模式的写法，大概分为以下六种： 1. 饿汉式1234567891011121314public class SingletonText &#123; public static SingletonText singletonText = new SingletonText(); //私有化构造方法 private SingletonText()&#123; &#125; public static SingletonText getInstance()&#123; return singletonText; &#125;&#125; 这种方式，简单粗暴，并且是线程安全的，主要适用于在初始化时，就要用到单例的情况，并且单例对象初始化速度很快，占内存比较小，不影响程序的启动速度，但是在实际项目中的单例模式不会这么简单，所以，一般用的不多！ 2. 懒汉式123456789101112131415161718public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText()&#123; &#125; public static SingletonText getInstance()&#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; return singletonText; &#125;&#125; 懒汉式，是在需要的时候才会做初始化单例对象的操作，适用于，初始化时，耗费时间较长，资源较多，不宜在程序启动时初始化，而且在多线程的环境下，并不是线程安全的。 3. 线程安全下的懒汉式-同步锁12345678910111213141516171819public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText()&#123; &#125; //添加 synchronized 关键字 public static synchronized SingletonText getInstance()&#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; return singletonText; &#125;&#125; 或者： 12345678910111213141516171819202122public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText()&#123; &#125; //添加 synchronized (SingletonText.class)&#123;&#125; public static SingletonText getInstance()&#123; synchronized (SingletonText.class)&#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; return singletonText; &#125; &#125;&#125; 4. 双重检验锁123456789101112131415161718192021222324public class SingletonText &#123; public static SingletonText singletonText; //私有化构造方法 private SingletonText() &#123; &#125; public static SingletonText getInstance() &#123; if (singletonText == null) &#123; synchronized (SingletonText.class) &#123; if (singletonText == null) &#123; singletonText = new SingletonText(); &#125; &#125; &#125; return singletonText; &#125;&#125; 在 synchronized (SingletonText.class) {} 之前加上 if (singletonText == null) 判断，减少获取锁的次数，从而提高性能，而这种也用的较多 5. 静态内部类1234567891011121314151617public class Singleton &#123; public static class SingletonText &#123; public static SingletonText singletonText = new SingletonText(); //私有化构造方法 private SingletonText() &#123; &#125; public static SingletonText getInstance() &#123; return SingletonText.singletonText; &#125; &#125;&#125; 只要程序中不使用这个内部类，就不会加载，从而实现了饿汉式的延迟加载，并且也是线程安全的。 6. 枚举实际上 Google 并不推荐使用枚举，因为与 class 相比，相同的静态常量，枚举占用的内存较多，个人认为，一旦涉及到内存，就算再方便也不能用，毕竟 Android 内存不多啊！ 总结：一共介绍了以上 6 种单例模式的书写方式，各有各的用途，看需求选择吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lottie 在 Android中的用法初探]]></title>
      <url>%2F2017%2F04%2F11%2FLottie%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[一、概述 Lottie 是一个由 Airbnb 开源的第三方动画库，它能够同时支持 iOS，Android 与 ReactNative 的开发； Lottie 通过 AE ( After Effects ) 中的 Bodymovin 插件将 AE 中制作好的动画导出成一个 json 文件，这个 json 文件就是我们需要的动画。 在 github 上有几种动画效果和源码介绍：https://github.com/airbnb/lottie-android CSDN 上也有一篇博文讲的不错：http://blog.csdn.net/trojx2/article/details/54896899 二、 AE 是什么 反正本人刚看到这个词的时候一脸懵逼，还专门去搜索了 - -！ Adobe After Effects ，没错，就是这个软件，由 Adobe 公司提供更新的，目前最新版本为 CC(13.5)。 由上边的这个软件来制作动画，然后导出为 json 格式的文件。 三、用法 本人目前并不会使用 AE ，而且， AE 还是收费软件，所以就在 github 上找了 json 文件，以写 demo 的形式来练习使用 1、 在概述中的 github 中找到 sample 文件中的 app/src/main/assets 目录下的 json 文件，随便选择一个，导入到自己项目的 assets 文件夹下2.在 app 的 build.gradle 中 添加如下依赖：123dependencies &#123; compile &apos;com.airbnb.android:lottie:2.0.0-beta4&apos;&#125; 3. 在布局文件中添加使用12345678&lt;com.airbnb.lottie.LottieAnimationView android:id=&quot;@+id/lottie&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:lottie_fileName=&quot;hello_AE.json&quot; app:lottie_loop=&quot;true&quot; app:lottie_autoPlay=&quot;true&quot; /&gt; 也可以在代码中使用，但是不知道为嘛代码方式老是找不到 assets 目录中的 json 文件 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RSA 算法 + AES 算法在 Android 中结合使用]]></title>
      <url>%2F2017%2F04%2F05%2FRSA%E7%AE%97%E6%B3%95-AES%E7%AE%97%E6%B3%95%E5%9C%A8Android%E4%B8%AD%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[前言加密算法在网络应用中越来越广，为了保证网络请求数据的安全，Android 网络请求中也越来越多的加入加密算法，本文主要是记录 RSA 和 AES 算法在 Android 中的应用 正文一、 概念1. RSA 算法 RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用 RSA 加密的信息实际上是不能被解破的。 RSA 算法属于非对称加密算法，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey），公钥加密，私钥解密；私钥加密，公钥解密。 随机生成一对公钥和私钥，客户端拿公钥，服务端拿私钥。 2. AES 算法 该算法为比利时密码学家 Joan Daemen 和 Vincent Rijmen 所设计，结合两位作者的名字，以 Rijndael 为名投稿高级加密标准的甄选流程。 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES。 每次用的时候随机生成一个秘钥，用完之后销毁 二、 使用流程1. 客户端和服务端用的 base64 加密类要一致，这个加密类是一个 jar 包，java 中有自带的 Base64 算法类，但是安卓中却没有，如果不统一 jar 包，解析要出错12javabase64-1.3.1.jar 2. 客户端使用示例代码操作步骤： 客户端随机产生 AES 的密钥 对身份证信息（重要信息）进行 AES 加密 通过使用 RSA 对 AES 密钥进行公钥加密 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; //需要加密的重要信息 private String name = &quot;zhangsan&quot;; private String idCard = &quot;4103271991***&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 加密-------------- */ // AES 产生的随机秘钥 String key = AESUtils.generateKey(); //加密之后的重要信息 String encryptName = AESUtils.encryptData(key, name); String encryptIdCard = AESUtils.encryptData(key, idCard); //对 AES 秘钥进行 RSA 加密 String encryptByPublicKey = RSAUtils.encryptByPublicKey(key); Log.i(&quot;RSAAndAES&quot;,&quot;AES秘钥为::::&quot;+key); Log.i(&quot;RSAAndAES&quot;,&quot;encryptName为::::&quot;+encryptName); Log.i(&quot;RSAAndAES&quot;,&quot;encryptIdCard为::::&quot;+encryptIdCard); Log.i(&quot;RSAAndAES&quot;,&quot;encryptByPublicKey为::::&quot;+encryptByPublicKey); &#125; 其中，RSA 的秘钥和公钥是提前生成好的，例如：1234567891011121314151617181920公钥： MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2Hy8d1jGGVlxNa3FEfeY5x9i5RxgICZvV/GO ekpyK/FxU+K44ft3EiUKGE12BS74lcO4j/1iIgbXV6CuonULSIzBwC52o7v2gFSW/5k+Mms 82q0OKu82Oosj2qYD+mlbfeCHxgPrdUwSeYxGWh1u/uM6r1hEkv9pKov+jWqyNuwIDAQAB私钥： MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALYfLx3WMYZWXE1rcUR95jnH2LlH GAgJm9X8Y56SnIr8XFT4rjh+3cSJQoYTXYFLviVw7iP/WIiBtdXoK6idQtIjMHALnaju/aAVJb/ mT4yazzarQ4q7zY6iyPapgP6aVt94IfGA+t1TBJ5jEZaHW7+4zqvWESS/2kqi/6NarI27AgMBAA ECgYBlbA5gLlWcO2Hh15DXlMluqiW+YKI4b6lyTMDpoTo+iHWe+HKFkdlMxyfd5NDw3U6CKVblg yE5vAqYmlgd6Z442cKtkiuFaBe6A6P2VHr8YLCVmB6QgRenASO4fCWqi5quEq/IvPhRpshRyuuJ cDnziMKx03RnEfZQRSbaK9K3cQJBANzxF1GoOdLsUmSaExhJKnirWXPsDbpu6IBmqUZdXQYDDmv hs0DJw/JQnuv0gm/gv6Qjy/v3fNHUFcPsQh0undMCQQDTBS6QjYU/2LKQ/RFoTTxLKrcPg3o66B 794jXR+kqLXJDO/UD88EMHHfOWo/QWVZvgdzQCGBErXk+rb41a8hd5AkEAxblUnxUnumUXT0S7d e50fc0Knr1Pg9qhY9d8AaaoCytNCqrPmll2bDJOJueIm8rMdn46nOFc6QMd/1o9yJPhVQJAVWGS XrC0SooObjXHFlGx5KQK378N9Mm4yHb/2c8Q3GR+vxGfevhn1nha+AesmmDXKjJxG6vLPqXxTGd dZX/w2QJBAM5jrVojC5mXQnA1eKzzRSCeAx97vzZX8wZpwqKVHmazd2kayUjzSARkm+P76+sB0G 96kGQJCRm7jEdl5jh5o2s=私钥的长度要比公钥长的多 Log 打印出来的结果大概是这样：123456AES秘钥为::::ecf82772a1ab4282encryptName为::::9ZaVuJNAKKwOpm7o+k0Tsg==encryptIdCard为::::DZ970wYy78lxpGfl0m3ziQ==encryptByPublicKey为::::iLAfMtFq23q+9AIp02KTO9KKq1kmeaN9E41evXJ7UZY7/c4FC2o1SadDZeB/EA6C9yurGI0X9HQhxtJC5JXwyEU2OVRqIx75a/ILaYyJ+AiJb06F/L/xfIS7nZBnb04dY65Bvbg1imr6SESKPuQOX5mJdgpbJZ0Vp2lj0ZGylbw= 3. 服务端使用代码示例操作步骤： 对加密后的 AES 密钥进行 RSA 私钥解密，拿到密钥原文； 对加密后的重要信息进行 AES 解密，拿到原始内容 123456 // 通过 RSA 私钥 还原 AES 秘钥String AESKEY = RSAUtils.decryptByPrivateKey(encryptByPublicKey);//通过 AES 秘钥 还原数据String name1 = AESUtils.decryptData(AESKEY, encryptName);String idCard1 = AESUtils.decryptData(AESKEY, encryptIdCard); 三、 为什么要两种算法配合使用 上边的例子大概是：客户端加密向服务端请求数据，服务端解密的过程。 而这种过程完全用 RSA 加密也能做到，两种算法结合的原因就是：AES 加密算法的解密速度要比 RSA 快得多，大概100倍。 还有一个原因：两种算法，多个秘钥，更加有利于信息安全。 四、 第三方链接 参考博文：http://www.10tiao.com/html/227/201704/2650239103/1.html 工具方法下载的第三方链接(不是本人)://download.csdn.net/detail/chay_chan/9766486]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dagger2 在 Android 中的使用]]></title>
      <url>%2F2017%2F03%2F30%2Fdagger2%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[前言dagger2 确实比较难上手，而我在写笔记之前也没完全整明白，只能记录些简单的应用 正文一、dagger2 是什么？dagger2 是依赖注入(Dependency Injection 简称 DI )框架中的一种，在编译期间自动生成代码，负责依赖对象的创建，貌似是目前最好的 DI 框架了。 二、为什么要用这玩意1. 增加开发效率，省去重复代码它可以把 new 对象的重复性工作做了，也能省去写单例方法的时间，也不用考虑单例模式的线程是否安全，因为这些都是 dagger2 的工作。 2. 进一步解耦 先说“解耦”的概念：解耦是为了让类与类、模块与模块之间的相互影响的关系降到最低，并不是说完全没有关系。 如果我们是通过 new 来创建对象的，那么当被 new 的对象所在的类的构造方法发生改变时，那么该类涉及到的类都要去修改，而 使用 dagger2 就不存在这方面的问题了。 3.方便测试三、如何使用1. 添加插件和依赖 在工程目录下的 bulid.gradle 中添加 apt 插件 12345dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos;&#125; 在 项目目录下的 bulid.gradle 中添加依赖 1234//版本最好匹配apt &apos;com.google.dagger:dagger-compiler:2.2&apos;compile &apos;com.google.dagger:dagger:2.2&apos;provided &apos;org.glassfish:javax.annotation:10.0-b28&apos; 2. 简单使用现在有这么一个场景： 一个类为： 123456789101112//注意：构造方法没有参数public class Hello &#123; public Hello()&#123; &#125; public String getSmg()&#123; return &quot;Hello,World!&quot;; &#125;&#125; 另一个类为： 12345678910public class MainActivity extends AppCompatActivity &#123; Hello hello;//我们要这个 hello 的对象 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; 那么，在 MainActivity 中要 Hello 类的对象，我们该怎么做？（除了 new ） 第一步 ：我们要在 Hello 类中用 @Inject 标注构造函数 1234@Injectpublic Hello()&#123;&#125; 第二步：在 MainActivity 中也添加 @Inject 123@InjectHello hello;//注意，不能用 private 修饰 第三步：需要一个 Component 作为连接 12345678//HelloComponent 可以是接口或者抽象类@Component()public interface HelloComponent &#123; //方法是固定写法，参数是因为要注入到 MainActivity 中 void inject(MainActivity activity);&#125; 第四步：还需要在 MainActivity 中做一些初始化操作 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; @Inject Hello hello; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化操作，注意被注入的 Hello 的构造方法是没有参数的 HelloComponent component = DaggerHelloComponent.builder() .build(); component.inject(this); &#125; 第五步：这样就把 Hello 对象 注入到 MainActivity 中了，可以验证一下 3. 如果被注入的类的构造方法有参数呢，那就要引入 ModuleModule 其中一个作用是为 构造方法提供参数用的， 我现在把 Hello 类的构造方法加上参数 123456789101112public class Hello &#123; @Inject public Hello(String msg)&#123; &#125; public String getSmg()&#123; return &quot;Hello,World!&quot;; &#125;&#125; 跟没有参数的构造方法相比，还要多加一步 1234567891011// 创建一个 XXXModule 要用 @Module 标注@Modulepublic class HelloModule &#123;//创建一个 providesXXX 方法，要用 @Provides 标注，返回值类型就是 Hello 构造方法的参数类型 @Provides public String providesReturnMessage()&#123; return &quot;Hello,World!&quot;; &#125;&#125; 同时， HelloComponent 也要做修改 123456789// @Component 后边加的东西，modules = 是固定写法 ， HelloModule.class 表示需要注入的类@Component( modules = HelloModule.class)public interface HelloComponent &#123; void inject(MainActivity activity);&#125; 另外 MainActivity 也要修改 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Inject Hello hello; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); HelloComponent component = DaggerHelloComponent.builder() //跟之前的相比，多了 .helloModule(new HelloModule()) //这样一来，就串在一起了 .helloModule(new HelloModule()) .build(); component.inject(this); &#125; 运行之后，也是对的 当然 dagger2 还有很多其他的注解和用法，以上是最简单的 Demo ，本人也没有在项目中实践过，无法提供更多的用法！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 中 Retrofit2.X 的使用(1)]]></title>
      <url>%2F2017%2F03%2F27%2FAndroid%20%E4%B8%AD%20Retrofit2.X%20%E7%9A%84%E4%BD%BF%E7%94%A8(1)%2F</url>
      <content type="text"><![CDATA[前言本文只是 Retrofit Android 端的常规使用 正文一、Retrofit 简介Retrofit 是 Square 公司开源的一个网络请求框架，适用于 Android 和 java ，采用注解的方式，简化网络请求，提高网络请求速度，底层为 Square 公司的 okhttp ！ 二、主要的请求方式和注解简介1. 主要的请求方式 格式 含义 @GET 表示这是一个GET请求 @POST 表示这个一个POST请求 @PUT 表示这是一个PUT请求 @DELETE 表示这是一个DELETE请求 @HEAD 表示这是一个HEAD请求 @OPTIONS 表示这是一个OPTION请求 @PATCH 表示这是一个PAT请求 2. 主要的注解 格式 含义 @Headers 添加请求头 @Path 替换路径 @Query 替代参数值，通常是结合get请求的 @FormUrlEncoded 用表单数据提交 @Field 替换参数值，是结合post请求的 三、简单使用例子1. 添加依赖和权限123//这两个依赖的版本要一致compile &apos;com.squareup.retrofit2:retrofit:2.2.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.2.0&apos; 12//添加网络请求权限&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&gt;&lt;/uses-permission&gt; 2. 创建网络请求接口12345678910111213import retrofit2.Call;import retrofit2.http.GET;import retrofit2.http.Path;import retrofit2.http.Query;//接口名称，随意命名public interface RetrofitText &#123; //@GET 表示是get请求 ， 而 @GET 后边括号里的是相对 @GET(&quot;sapientialMall/getLadderInfo.action&quot;) Call&lt;RetrofitTextBean&gt; getRequest(@Query(&quot;market_id&quot;) int markret_id , @Query(&quot;floor_start&quot;) int floor_start , @Query(&quot;floor_end&quot;) int floor_end ); &#125; 说明： 这是一个接口，接口名称随意命名 @GET 表示是 get 请求 ， 而 @GET 后边括号里的是相对地址，例如：www.baidu.com/aaaa/bbbb/ccccc ，其中 aaaa/bbbb/ccccc 就是相对地址。 Call 是固定写法，后边&lt;&gt;中的 RetrofitTextBean 是根据请求结果的 json 字符串生成的 javaBean getRequest 方法名一般采用 getXXX的形式 @Query 是配合 GET 请求用的，后边的括号内为拼接在 url 后的请求参数 key ，而 int 类型的 markret_id 为 value 3. 开始异步请求 （ GET 请求）123456789101112131415161718192021222324//1.创建 Retrofit 实例，并完成相关配置Retrofit retrofit = new Retrofit.Builder()//baseUrl 为 www.baidu.com/aaaa/bbbb/ccccc 中的 www.baidu.com/ .baseUrl(baseUr) //表示调用 Gson 库来解析返回值，将结果直接解析为 javaBean 对象 .addConverterFactory(GsonConverterFactory.create()) .build();//2.创建接口对象，即 RetrofitText 接口的对象RetrofitText retrofitText = retrofit.create(RetrofitText.class);//3.获取请求服务方法Call&lt;RetrofitTextBean&gt; call = retrofitText.getRequest(1, 5, -3);//4.开始异步请求call.enqueue(new Callback&lt;RetrofitTextBean&gt;() &#123; @Override public void onResponse(Call&lt;RetrofitTextBean&gt; call, Response&lt;RetrofitTextBean&gt; response) &#123; //请求成功 &#125; @Override public void onFailure(Call&lt;RetrofitTextBean&gt; call, Throwable t) &#123; //请求失败 &#125;&#125;); 四、GET 请求扩展（以第三条的例子为基础）1. 另一种接口定义方式123456789101112131415import retrofit2.Call;import retrofit2.http.GET;import retrofit2.http.Path;import retrofit2.http.Query;import retrofit2.http.Url;public interface RetrofitText &#123; @GET(&quot;&quot;) Call&lt;RetrofitTextBean&gt; getRequest2(@Url String url , @Query(&quot;market_id&quot;) int markret_id , @Query(&quot;floor_start&quot;) int floor_start , @Query(&quot;floor_end&quot;) int floor_end );&#125; 说明： 这种定义方式，是在获取请求方法的时候才传入相对地址，更加灵活一点，如下所示： 1Call&lt;RetrofitTextBean&gt; call = retrofitText.getRequest2(&quot;这里是相对地址&quot;, 1, 5, -3); 2. 还有一种接口定义方式12@GET(&quot;sapientialMall/getLadderInfo.action&quot;)Call&lt;RetrofitTextBean&gt; getRequest4(@QueryMap Map&lt;String , Integer &gt; map); 说明： 这种适合参数比较多，且参数的数据类型一致时，使用 未完待续~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AndroidStudio中使用butterknife]]></title>
      <url>%2F2017%2F03%2F27%2FAndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8butterknife%2F</url>
      <content type="text"><![CDATA[前言全程鼠标和快捷键操作，不需要手动添加一行代码！ 正文 butterknife 的 github 地址： https://github.com/JakeWharton/butterknife 一、使用原因butterknife 主要是为了解决 findViewById 和 onClick 的重复和繁琐，提高我们的编码效率而出现的。 缺点：虽然说 findViewById 比较繁琐，但是我们一看就明白，而通过注解的方式，个人觉得代码的阅读性会变差，但是随着熟练度的增加，这个缺点也可以忽视了。 二、使用方法1. 打开 Android Studio 的设置页面下载插件 Android ButterKnife Zelezny ，安装完毕后重启 Android Studio ，如下图所示： 2.在 Activity 或者 Fragment 中，鼠标放在资源文件上，快捷键 Alt+Insert ，或者鼠标右键选择，选择 Generate ，如下图所示： 3.在 app 下的 bulid.gradle 中添加如下依赖：1234567dependencies &#123; compile &apos;com.jakewharton:butterknife:8.5.1&apos; compile &apos;com.jakewharton:butterknife-compiler:8.5.1&apos; //8之前只需要第一个依赖就行了，8之后需要这两个依赖&#125; 也可以使用图形化界面添加依赖：打开 file - Project Structure -选中 app -切换到 Dependencies - 点击右侧加号 - 搜索 butterknife ， 如图所示： 4.选择 Generate Butterknife Injections 之后，会弹出以下窗口： 其中：onClick 选项为：是否添加点击事件。Variable Name 表示：生成的变量名称。Creat ViewHolder 表示：是否创建为 ViewHolder。Split Onclick methods 表示：点击事件分开或者合并。 5.创建完成之后，如下方图片和代码所示： 123456789101112131415161718192021222324252627 @BindView(R.id.text_1)TextView text1;@BindView(R.id.text_2)TextView text2;@BindView(R.id.btn_1)Button btn1;@BindView(R.id.btn_2)Button btn2;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this);&#125;@OnClick(&#123;R.id.btn_1, R.id.btn_2&#125;)public void onViewClicked(View view) &#123; switch (view.getId()) &#123; case R.id.btn_1: break; case R.id.btn_2: break; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中的消息机制--Handler]]></title>
      <url>%2F2017%2F03%2F24%2FAndroid%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6-Handler%2F</url>
      <content type="text"><![CDATA[前言网上关于Handler机制运行原理的文章已经很多，但毕竟不是自己的，也不一定适合自己的阅读习惯！ 一、概述 Android 的消息机制主要是指 Handler 的运行机制， Handler 的运行需要底层的 MessageQueue 和 Looper 支撑，这三者实际上是一个整体 ( 配套使用 ) ，只不过我们在开发过程中比较多的接触到 Handler 而已。 说到 Handler ，很多人都知道是为了更新 UI ，这不错，但这只是 Handler 的一个应用场景而已。 Handler 出现的原因，我想是因为不能在主线程中做耗时操作，一旦耗时操作超过 5s 就会出现 ANR 异常，下面代码是 Handler 的最常用用法: 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; private Handler myHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //主线程中处理发送过来的message &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //子线程中发送Handler消息 new Thread()&#123; @Override public void run() &#123; Message msg = new Message(); msg.what = 1; myHandler.sendMessage(msg); &#125; &#125;.start(); &#125; &#125;&#125; 注意： 线程中默认是没有 Looper的，如果想要使用 Handler 就必须为线程创建 Looper ，否则会报错，Looper 是运行在 Handler 所在的线程中的。 主线程比较特殊，它在创建的时候就会初始化 Looper，会调用 Looper.prepaerMainLooper() 来创建主线程的 looper 以及 MessageQueue ，也就是说，在主线程中默认可以使用 Handler 。 大致的原理： Handler 通过 send 或 post 的 一系列方法发送 message 到 MessageQueue 。 MessageQueue 翻译过来叫做消息队列，内部存储 Handler 发送过来的一系列消息，仅仅能存储消息，数据存储结构为单链表。 Looper 会以无限循环的方式从 MessageQueue 中查找是否有新消息，如果有就处理消息，否则就一直等待着。 二、详细分析主要介绍下 ThreadLocal 、 Handler 、 MessageQueue 、Looper 1. ThreadLocalThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只能在指定线程中才可以获取到存储的数据。 介绍 ThreadLocal 是因为不同线程的 Handler 获取对应 Looper 采用的就是这个原理。 举个例子： 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; //ThreadLocal 对象，存储的是 boolean 值 private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mBooleanThreadLocal.set(true); Log.i(&quot;Thread---Main:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); new Thread(&quot;Thread---1&quot;)&#123; @Override public void run() &#123; mBooleanThreadLocal.set(false); Log.i(&quot;Thread---1:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); &#125; &#125;.start(); new Thread(&quot;Thread---2&quot;)&#123; @Override public void run() &#123; Log.i(&quot;Thread---2:&quot;,mBooleanThreadLocal.get()+&quot;&quot;); &#125; &#125;.start(); &#125; 代码中，在主线程中设置 mBooleanThreadLocal 为 true ，在 Thread—1 中设置 mBooleanThreadLocal 为 false ，在 Thread—2 中没有设置， mBooleanThreadLocal 通过 set() 和 get() 方法进行数据的设置和取出操作。 打印出来的结果为： 12312945-12945/? I/Thread---Main:: true12945-12959/? I/Thread---1:: false12945-12960/? I/Thread---2:: null 2. MessageQueue翻译过来为消息队列，其主要包含两个操作：插入和读取，分别对应 MessageQueue 的两个方法 enqueueMessage() 和 next() ，另外，读取过的消息会删除掉！ 3. LooperLooper 会不停的从 MessageQueue 中查看是否有新消息，有就立刻处理，否则就一直阻塞，在 Looper 的构造方法中会创建一个 MessageQueue 对象，再次印证了那四个字—配套使用。 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; 除了主线程之外，在其他线程中如何创建 Looper 对象，如下所示： 1234567891011121314new Thread(&quot;Thread---1&quot;)&#123; @Override public void run() &#123; //创建 Looper 对象 Looper.prepare(); Message msg = new Message(); msg.what = 1; myHandler.sendMessage(msg); //开启消息循环 Looper.loop(); &#125; &#125;.start(); 获取主线程 Looper， 通过方法：Looper.getMainLooper(); Looper 退出，有两个方法，Looper 的 quit() 和 quitSafely() ，其内部还是让 MessageQueue 的 next 方法返回 null ， next 方法返回 null 是唯一的退出方式 ，建议不需要的时候终止 Looper。 quit() 是直接退出 Looper 。 quitSafely() 是把已有的消息处理完之后才安全退出。 4. Handlerhandler 的工作主要是发送和接收消息的过程 发送消息是通过一系列的 send 和 post 方法来发送的，而 post 的一系列方法最终还是通过 send 实现的，发送一条消息的过程如下： 123456789101112131415161718192021222324252627282930313233public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 从上边可以发现，Handler 发送消息，实际上只是在消息队列中插入了一条消息。 MessageQueue 的 next 方法会将这条消息返回给 Looper ，最终这条消息由 Looper 交给 Handler 的 dispatchMessage 方法处理，如下所示： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 最后，调用 Handler 的 handlerMessage 方法来处理消息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android6.0运行时权限插件版]]></title>
      <url>%2F2017%2F03%2F23%2Fandroid6-0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%8F%92%E4%BB%B6%E7%89%88%2F</url>
      <content type="text"><![CDATA[前言：介绍运行时权限的第三方库 PermissionsDispatcher 配合 AndroidStudio 的使用 PermissionsDispatcher 库地址： PermissionsDispatcher 本文来源： https://github.com/alidili/PermissionDemo 正文：PermissionsDispatcher 通过注解的方式，动态生成类处理运行时权限。配合插件使用，可自动生成代码。 使用： 1. 在 AndroidStudio中搜索插件 PermissionsDispatcher ，并下载安装2. 将下面这段代码添加到 project 的 build.gradle 文件中：12345buildscript &#123; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125;&#125; 3. 将下面的代码添加到app module的build.gradle文件中，目前最新版本为 2.3.2 ,不过参考的文章用的 2.1.3，我也就没改123456apply plugin: &apos;android-apt&apos;dependencies &#123; compile &apos;com.github.hotchemi:permissionsdispatcher:2.1.3&apos; apt &apos;com.github.hotchemi:permissionsdispatcher-processor:2.1.3&apos;&#125; 4. 准备工作已经完成了，下面来进行代码的生成，在 Android Studio 中选择 Code — Generate — Generate Runtime Permissions，也可以快捷键 Alt + Insert ，选择 Generate Runtime Permissions ，如下图所示： 其中： 1234567@NeedsPermission 当申请的权限被用户允许后，调用此方法。@OnShowRationale 当第一次申请权限时，用户选择拒绝，再次申请时调用此方法， 在此方法中提示用户为什么需要这个权限。@OnPermissionDenied 当申请的权限被用户拒绝后，调用此方法x`@OnNeverAskAgain 当用户点击不再询问后，调用此方法。 5. 代码大致如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.yang.permissiondemo;import android.Manifest;import android.annotation.TargetApi;import android.content.DialogInterface;import android.graphics.Color;import android.os.Build;import android.os.Bundle;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.widget.TextView;import android.widget.Toast;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;import permissions.dispatcher.NeedsPermission;import permissions.dispatcher.OnNeverAskAgain;import permissions.dispatcher.OnPermissionDenied;import permissions.dispatcher.OnShowRationale;import permissions.dispatcher.PermissionRequest;import permissions.dispatcher.RuntimePermissions;@RuntimePermissionspublic class PermissionsDispatcherActivity extends AppCompatActivity &#123; @Bind(R.id.tv_permission_status) TextView tvPermissionStatus; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_request_permission) public void onClick() &#123; requestPermission(); &#125; @TargetApi(Build.VERSION_CODES.M) private void requestPermission() &#123; //申请权限 PermissionsDispatcherActivityPermissionsDispatcher.openCameraWithCheck(this); &#125; @NeedsPermission(Manifest.permission.CAMERA) void openCamera() &#123; tvPermissionStatus.setTextColor(Color.GREEN); tvPermissionStatus.setText(&quot;相机权限已申请&quot;); &#125; @OnShowRationale(Manifest.permission.CAMERA) void showRationale(final PermissionRequest request) &#123; new AlertDialog.Builder(this) .setMessage(&quot;申请相机权限&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; //再次执行请求 request.proceed(); &#125; &#125;) .show(); &#125; @OnPermissionDenied(Manifest.permission.CAMERA) void permissionDenied() &#123; Toast.makeText(this, &quot;权限被拒绝&quot;, Toast.LENGTH_SHORT).show(); &#125; @OnNeverAskAgain(Manifest.permission.CAMERA) void neverAskAgain() &#123; Toast.makeText(this, &quot;不再询问&quot;, Toast.LENGTH_SHORT).show(); &#125; @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); PermissionsDispatcherActivityPermissionsDispatcher.onRequestPermissionsResult(this, requestCode, grantResults); &#125;&#125; 注： PermissionsDispatcherActivityPermissionsDispatcher 这个类本来是没有的需要先编译一次才会出现，点击 Build - Make Project。 6. 兼容性，为了保持兼容性建议使用v4包的兼容方法：1234ContextCompat.checkSelfPermission() ActivityCompat.requestPermissions()ActivityCompat.OnRequestPermissionsResultCallback()ActivityCompat.shouldShowRequestPermissionRationale()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android6.0运行时权限使用流程]]></title>
      <url>%2F2017%2F03%2F23%2Fandroid6.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前言：本文不涉及第三方的类库和工具，只是原生的操作流程 一、简介Android6.0 之前，用户安装 app ,会根据声明的权限生成一个权限列表，只有用户同意才能完成安装，而用户一般也不会注意这些权限，有可能会造成一些私密权限的泄漏，从而威胁到我们手机本身的信息安全！ Android6.0之后，运行时权限解决了这一问题，用户可以直接安装 app ，一些高危权限会在应用运行的过程中动态申请，我们可以选择同意或者拒绝，也可以在设置界面对每个 app 的权限进行查看和修改。 二、权限简介官网上有句话，系统权限分为几个保护级别，需要了解的最重要的两个是 正常权限 和 危险权限 ，而运行时权限就是针对危险权限而言的。 危险权限官网定义： 危险权限涵盖应用需要涉及用户隐私信息的数据或资源，或者可能对用户存储的数据或其他应用的操作产生影响的区域。例如，能够读取用户的联系人属于危险权限。如果应用声明其需要危险权限，则用户必须明确向应用授予该权限。 危险权限种类： 注意：左侧为权限组，右侧为权限组的具体权限，同一组内的任何一个权限被授权了，其他权限也自动被授权，系统只告诉用户应用需要的权限组，而不告知具体权限！ 使用流程 需要将 app 的 targetSdkVersion 设置到 23 及其以上，这样才有可能触发运行时权限。 在AndroidManifest文件中添加所需要的权限。 先检查系统版本，如果系统在 6.0 以上，采取运行时权限，版本名称和版本号参考官网：https://developer.android.com/reference/android/os/Build.VERSION_CODES.html 1Build.VERSION.SDK_INT &gt;= 23 几个重要的 API 12345678910 检查某个权限是否被授予 ，以相机权限为例if ( ContextCompat.checkSelfPermission ( this,Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED ) &#123; //申请相机权限操作&#125;else&#123; //相机权限已申请操作&#125; 123456789该方法只有在用户在上一次已经拒绝过你的这个权限申请。也就是说，用户已经拒绝一次了，你又弹个授权框，你需要给用户一个解释，为什么要授权，则使用该方法，只有第一次被拒绝，当第二次申请时， if 条件为 true，其他都为 falseif (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; &#125; 12345678910申请相机权限操作第一个参数是Context；第二个参数是需要申请的权限的字符串数组；第三个参数为requestCode， 主要用于回调时候监测其中第二个参数支持一次性申请多个权限的，系统会通过对话框逐一询问用户是否授权ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, CAMERA_REQUEST_CODE); 123456789101112131415161718192021此方法是权限申请的回调方法，在此方法中处理权限申请成功或失败后的操作。@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case CAMERA_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限申请成功操作 &#125; else &#123; //权限申请失败 //用户勾选了禁止后不再询问，提示用户手动打开权限 &#125; return; &#125; &#125;&#125; 完整的操作流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//判断系统版本是否大于23 private boolean isRequestPermission() &#123; return Build.VERSION.SDK_INT &gt;= 23; &#125; //自定义请求权限 private void requestPermission() &#123; if (!isRequestPermission()) &#123; return; &#125; //检查是否已经拥有该权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123; //判断是否是第二次申请，（第一次被用户拒绝），如果是的话，做一些说明，一般是弹框说明 if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) &#123; //弹出一个dialog，说明第二次请求原因 new AlertDialog.Builder(this) .setMessage(&quot;申请照相机权限&quot;) .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CAMERA&#125;, CAMERA_REQUEST_CODE ); &#125; &#125;).show(); &#125; else &#123;//不是的话就执行申请操作 ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;&#125;, CAMERA_REQUEST_CODE ); &#125; &#125; else &#123; //相机权限已申请操作 &#125; &#125; /** * 权限申请回调 * * @param requestCode 请求码 * @param permissions 请求的权限列表 * @param grantResults 请求的结果列表 */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case CAMERA_REQUEST_CODE: &#123; if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; //权限申请成功操作 &#125; else &#123; //权限申请失败 //用户勾选了禁止后不再询问，提示用户手动打开权限 if (!ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.CAMERA))&#123; Toast.makeText(MainActivity.this,&quot;请在设置列表打开相机权限&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; return; &#125; &#125; &#125; 有几位大神总结的很不错，附上链接 Hongyang大神 郭霖大神]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔感受]]></title>
      <url>%2F2017%2F03%2F22%2F%E9%9A%8F%E7%AC%94%E6%84%9F%E5%8F%97%2F</url>
      <content type="text"><![CDATA[前言生活中从不缺少感悟和体会，我要把这些感想记录下来，以后再看或许是些宝贵的经验！ 1. 结缘小密圈结缘小密圈说起来也很凑巧，也很幸运，自己的微信有很多技术性的公众号，关注的原因无非就是为了多学点东西，其中有一个叫做 「AndroidDevelop」 ，是看过他的一篇博客然后搜索添加的，这个公众号的主人叫做 「stormzhang」 ，人称 帅比张，一直在看他写的文章，也觉得不错，然后有一天看到此人开通小密圈了，然后果断下载付费入圈 —– 「帅比张读者圈」，时间是 2月27号 ，现在想来，挺幸运的，要不我得错过多少好东西，入圈没几天就感觉值回票价了！！ 注：此博客就是在加入小密圈之后才了解并搭建的！ 2. 写作动力我不是一个喜欢写东西的人，现在才了解到原因，是因为我还没了解到写作的好处！写作不仅能提高逼格，更重要的是，让我学会梳理和记录平时所学，从而提高学习和解决问题的效率，记录自己，帮助他人！ 有些东西，脑子里边知道，能说出来，不一定能写的出来 3. 写作排版说实话，之前就算写东西也从来没注意过这些东西，当初写的目的仅仅是为了记录一些东西，由于写的比较乱和杂，也导致很多东西时间长就丢了，帅比张分享了一些关于排版的规格，按照规格一来，确实好看了不少，当然我现在还是初学者，有待改进！ 4.独立思考和选择当遇到两难抉择的问题时，只需要把所有的选择罗列出来，利弊各自写下来，这样就一目了然了！ 5. 付费买知识付费买知识是我个人意识的重大改变，谁的时间都不是免费的，你占用别人的时间来为你回答问题，难道不应该掏钱么？ 可能书买了不会去看，但是如果让你付费问别人问题，你会么？，如果会的话，我想这个问题的答案肯定会记得牢一点！ 我感觉这跟我们找人办事请吃饭差不多，只不过换了个的场景！ 6.只字不差的阅读我认为阅读越细越好，特别是一些技术文章，细致的阅读能让人深入进去，从而提炼更为有用的东西，这也是我要提高的地方！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git命令总结]]></title>
      <url>%2F2017%2F03%2F21%2FGit%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言：由于在搞博客的原因，顺带着多了解了点 Git 命令，欢迎大家指正！ 一、Git工具下载地址：https://git-scm.com/download/安装也很简单，基本就是一直下一步，选默认的就好！ 二、常用命令介绍1. 本地文件夹与 github 远程仓库建立连接在需要建立连接的文件夹，右键 Git Bash 输入： 12git initgit remote add origin &lt;server&gt; 其中，server是 github 远程仓库地址，origin只是仓库的一个别名，这里可以随意变！ 2. 将本地的文件，同步到 github 远程仓库上123git add . #添加所有目录，后边有个点git commit -m &quot;message&quot; #添加提交说明信息git push -u origin master #云端同步 3. 把 github 上的文件取回本地在本地先建立一个文件夹，右键 Git Bash 输入： 1234git initgit remote add origin &lt;server&gt; # server是远程仓库地址git fetch –allgit merge origin/master #这个origin与步骤 1 的那个一致 4. 如果两个PC端操作一个远程仓库地址12每次先 git pull 进行同步更新，然后执行步骤 2 5.修改 github 远程仓库地址 第一种方式：在需要修改远程地址的文件夹下 右键 Git Bash 输入： 12git remote rm origin #先删除git remote add origin &lt;server&gt; #重新添加地址 第二种方式：找到.git文件夹下的config文件 找到 [remote “origin”]，下边的url就是远程仓库地址，修改成自己需要的就好！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Hexo-Github---搭建个人博客笔记]]></title>
      <url>%2F2017%2F03%2F19%2F%E5%9F%BA%E4%BA%8EHexo-Github-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%AC%94%E8%AE%B0-1%2F</url>
      <content type="text"><![CDATA[前言:为了搭建这个博客，踩得坑不计其数，说焦头烂额也不为过．参考博客： 基于Hexo+GitHub Pages 搭建个人博客教程 正文：一、环境的搭建 Note.js下载和安装 1.下载地址：https://nodejs.org/en/download/ 2.windows下安装非常简单 参考地址：http://www.runoob.com/nodejs/nodejs-install-setup.html Git下载和安装 1.下载地址：https://git-scm.com/download/ 2.windows下安装也很简单，参考地址：http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html 二、安装Hexo 桌面上鼠标右键打开Git Bash。 输入安装命令 1npm install -g hexo-cli 选择硬盘目录作为存放文件的路径 1hexo init e:\blog #在E盘先创建一个blog文件夹存放文件 进入该目录后再进行其他操作 1cd e:\blog 执行安装依赖包的命令 1npm install 生成部署文件，启动本地服务 123hexo g # 或者hexo generate hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 现在我们打开 http://localhost:4000/ 就可以看到我们刚才搭建的本地博客了，Hexo会默认生成一个Hello World的博文。 停止是ctrl+c hexo几个常用命令123456hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署博客到远端服务器hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 三、github Pages设置 登录github官网创建github账号： http://www.github.com/ 创建仓库: 点击右侧+号，new repository 仓库名字必须是 username/username.github.io ，这是特殊的命名约定。 username 就是注册的github账号名字 配置 ssh 检查本地是否存在 ssh ，如果存在就删除 .ssh文件夹 1ls -al ~/.ssh 设置 name 和 email ，注意：这里的那么和email是随意的，并没有特别的限定 12git config --global user.name &quot;&lt;your name&gt;&quot;git config --global user.email &quot;&lt;your email&gt;&quot; 生成 ssh 秘钥 ，这里的邮箱是注册 github 的邮箱 1ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot; 一路回车，可以设置密码，如果设置要记住后边要用 这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub 打开 id_rsa.pub 复制全部内容，这就是 ssh 秘钥 配置 ssh 秘钥 在自己的 github 主页，点击右侧头像下的 setting ，选择 SSH and GPG keys , 然后点击 New SSH key，粘贴刚才复制的 SSH 保存。 检查是否配置成功 ，输入以下命令 1ssh git@github.com 成功的话会显示以下内容 1234567The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 四、部署到 github 配置 _config.yml ，在自己创建的 blog 目录下 ，最下方。 1234567# Deployment## Docs: https://hexo.io/docs/deployment.html# ssh://git@github.com/git-xuhao/git-xuhao.github.iodeploy: type: git repo: ssh://git@github.com/git-xuhao/git-xuhao.github.io branch: master 其中，repo是我们刚刚建立的远程仓库，换成你自己的仓库，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误 安装 git 包 1npm install hexo-deployer-git --save 部署到 github 上 1hexo deploy 现在我们可以通过访问 http://adsuper.github.io/ 来访问我们自己的博客啦，其中链接是自己的仓库名。 五、Hexo 配置文件常用到的配置文件一共有两个，分别是blog根目录下的 _config.yml 和 主题下的 _config.yml ，(themes文件夹的为主题)； 关于配置文件的具体描述请参考： https://hexo.io/zh-cn/docs/configuration.html 六、如何使用？ 新建一篇博文可通过以下的命令 ，要在bolg根目录下打开 Git Bash 1hexo new &quot;name&quot; 其中name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件 博文写好之后，在每次发布之前，我们要先将写好的博客生成静态文件，执行以下命令 1hexo g 静态文件生成之后，便可以部署到GitHub上 hexo d 然后打开我们的博客，就可以看到我们刚刚新建的博文了 七、主题推荐Hexo提供了许多的主题可供我们选择和使用，在./themes目录下存放主题。刚才默认生成的博客用的就是默认的主题landscape。 主题推荐请参考： https://github.com/hexojs/hexo/wiki/Themes 我自己使用的是 Next 主题。 Next主题的配置方法参考： http://theme-next.iissnan.com/getting-started.html]]></content>
    </entry>

    
  
  
</search>
